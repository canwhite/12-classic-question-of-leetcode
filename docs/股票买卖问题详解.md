# 股票买卖问题详解 (小白版)

## 问题描述
给你一个数组 `prices`，其中 `prices[i]` 是第 i 天的股票价格。你可以在任何一天买入，在任何后面的一天卖出，并且可以进行多次买卖，但不能同时持有多个股票。求最大利润。

## 举个例子
假设股票价格为：`[7, 1, 5, 3, 6, 4]`

一个最优的策略是：
- 第1天买入（价格 = 1）
- 第2天卖出（价格 = 5），利润 = 5 - 1 = 4
- 第3天买入（价格 = 3）
- 第4天卖出（价格 = 6），利润 = 6 - 3 = 3

总利润 = 4 + 3 = 7

## 算法思路：动态规划

### 核心思想
动态规划就是把大问题分解成小问题，先解决小问题，然后组合起来解决大问题。

### 状态定义
我们为每一天定义两种状态，主要好似区分出来有几种状态

1. **`hold[i]`** - 第 i 天结束时**持有**股票时的最大利润
2. **`notHold[i]`** - 第 i 天结束时**不持有**股票时的最大利润

### 状态转移（怎么从昨天的状态得到今天的状态）

#### 第 i 天持有股票 (`hold[i]`)
有两种方式：
1. **保持持有**：昨天就持有，今天什么都不做
2. **今天买入**：昨天不持有，今天买入股票

```go
hold[i] = max(hold[i-1], notHold[i-1] - prices[i])
```

#### 第 i 天不持有股票 (`notHold[i]`)
也有两种方式：
1. **保持不持有**：昨天就不持有，今天什么都不做
2. **今天卖出**：昨天持有，今天卖出股票

```go
notHold[i] = max(notHold[i-1], hold[i-1] + prices[i])
```

### 初始化
第 0 天（第一天）的情况：
- `hold[0] = -prices[0]` （第一天买入股票，花掉 `prices[0]` 元钱，利润为负）
- `notHold[0] = 0` （第一天什么都不做，利润为0）

### 详细计算过程

还是用例子 `[7, 1, 5, 3, 6, 4]`：

**第0天（价格 = 7）：**
- `hold[0] = -7` （买入股票）
- `notHold[0] = 0` （不操作）

**第1天（价格 = 1）：**
- `hold[1] = max(hold[0], notHold[0] - prices[1]) = max(-7, 0 - 1) = -1`
  - 保持持有：-7
  - 今天买入：0 - 1 = -1
  - 选择更好的：-1
- `notHold[1] = max(notHold[0], hold[0] + prices[1]) = max(0, -7 + 1) = 0`
  - 保持不持有：0
  - 今天卖出：-7 + 1 = -6
  - 选择更好的：0

**第2天（价格 = 5）：**
- `hold[2] = max(hold[1], notHold[1] - prices[2]) = max(-1, 0 - 5) = -1`
- `notHold[2] = max(notHold[1], hold[1] + prices[2]) = max(0, -1 + 5) = 4`
  - 保持不持有：0
  - 今天卖出：-1 + 5 = 4
  - 选择更好的：4

**第3天（价格 = 3）：**
- `hold[3] = max(hold[2], notHold[2] - prices[3]) = max(-1, 4 - 3) = 1`
- `notHold[3] = max(notHold[2], hold[2] + prices[3]) = max(4, -1 + 3) = 4`

**第4天（价格 = 6）：**
- `hold[4] = max(hold[3], notHold[3] - prices[4]) = max(1, 4 - 6) = 1`
- `notHold[4] = max(notHold[3], hold[3] + prices[4]) = max(4, 1 + 6) = 7`

**第5天（价格 = 4）：**
- `hold[5] = max(hold[4], notHold[4] - prices[5]) = max(1, 7 - 4) = 3`
- `notHold[5] = max(notHold[4], hold[4] + prices[5]) = max(7, 1 + 4) = 7`

### 最终答案
因为最后一天不能持有股票（否则股票的价值没有被变现），所以答案是 `notHold[5] = 7`。

## 代码实现

```go
func MaxProfit(prices []int) int {
	if len(prices) == 0 {
		return 0
	}

	// 动态规划解法：DP[i]表示第i天能获得的最大利润
	// 状态：持股或不持股
	hold := make([]int, len(prices))   // 持股时的最大利润
	notHold := make([]int, len(prices)) // 不持股时的最大利润

	// 初始化
	hold[0] = -prices[0] // 第0天买入，利润为-price[0]
	notHold[0] = 0        // 第0天不持股，利润为0

	for i := 1; i < len(prices); i++ {
		// 持股状态：要么保持持股，要么从不持股状态买入
		hold[i] = max(hold[i-1], notHold[i-1]-prices[i])

		// 不持股状态：要么保持不持股，要么从持股状态卖出
		notHold[i] = max(notHold[i-1], hold[i-1]+prices[i])
	}

	// 最终结果必须是不持股状态（不能持有股票）
	return notHold[len(prices)-1]
}
```

## 空间优化版本

我们注意到每次计算只需要前一天的数据，所以可以优化空间复杂度：

```go
func MaxProfit(prices []int) int {
	if len(prices) == 0 {
		return 0
	}

	// 只保存前一天的状态
	hold, notHold := -prices[0], 0

	for i := 1; i < len(prices); i++ {
		newHold := max(hold, notHold - prices[i])
		newNotHold := max(notHold, hold + prices[i])
		hold, notHold = newHold, newNotHold
	}

	return notHold
}
```

## 时间复杂度和空间复杂度

- **时间复杂度**：O(n)，需要遍历价格数组一次
- **空间复杂度**：O(1)（优化版本），只需要常数空间存储几个变量

## 核心要点总结

1. **动态规划**：把大问题分解成子问题，通过子问题的最优解构建整个问题的最优解
2. **状态定义**：每天有持有和不持有两种状态
3. **状态转移**：今天的状态取决于昨天的状态和今天的决策
4. **最优子结构**：每一天的最优解都包含了前面所有天数的最优决策
5. **最终状态**：必须是不持有股票的状态才算真正的利润

这就是股票买卖问题的完整解析！记住这个"持有/不持有"的状态定义，很多类似的金融交易问题都可以用这种思路解决。