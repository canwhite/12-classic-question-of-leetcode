# 接雨水问题之动态规划详解

## 🎯 三步递归法分析：接雨水问题

### **第一步：分析最后一步**

**问自己：** 要计算总接水量，最后一步能做什么？

```
核心问题：每个位置能接多少水？
答案：每个位置独立计算，然后相加

对于位置i的接水量，最后一步是：
- 确定左边最高的柱子（西墙）
- 确定右边最高的柱子（东墙）
- 取两边较矮的那个作为水位高度
- 减去当前位置的柱子高度

所以：
water[i] = min(左边最高, 右边最高) - height[i]
```

**关键观察：**
- 每个位置的接水量是独立的
- 不依赖于其他位置的水量
- 只依赖于左右两边的高度信息
- 边界位置无法接水（缺少一边的墙）

### **第二步：建立状态联系**

**问自己：** 当前状态如何从前面状态得出？

```
状态定义：
leftMax[i] = 位置0到i的最高柱子高度
rightMax[i] = 位置i到n-1的最高柱子高度

左边最大高度的递推关系：
要计算位置i左边最高：
要么就是位置i-1左边最高（不含i）
要么就是位置i本身的高度（如果i更高）

所以：leftMax[i] = max(leftMax[i-1], height[i])

右边最大高度的递推关系：
要计算位置i右边最高：
要么就是位置i+1右边最高（不含i）
要么就是位置i本身的高度（如果i更高）

所以：rightMax[i] = max(rightMax[i+1], height[i])
```

**递推方向：**
```
leftMax：从左到右递推（需要leftMax[i-1]）
rightMax：从右到左递推（需要rightMax[i+1]）
```

### **第三步：验证边界情况**

**问自己：** 最小的子问题答案是什么？

```
数组长度为0：
没有柱子，接水量为0

数组长度为1：
只有一根柱子，无法形成容器，接水量为0

数组长度为2：
两根柱子，没有中间位置接水，接水量为0

递推边界：
leftMax[0] = height[0]     // 位置0左边最高就是自己
rightMax[n-1] = height[n-1] // 位置n-1右边最高就是自己

计算边界：
首尾位置（i=0和i=n-1）不能接水，因为缺少一边的墙
计算范围：i从1到n-2
```

---

## 🚀 完整递推实现

#### 演绎推导的代码实现

```go
// 方法2：动态规划解法
// 思路：预处理每个位置左边和右边的最大高度，计算接水量
// 时间复杂度：O(n)，空间复杂度：O(n)
func Trap2(height []int) int {
    n := len(height)
    if n == 0 {
        return 0
    }

    // 预处理左边最大高度
    leftMax := make([]int, n)
    leftMax[0] = height[0]  // 边界条件：第一个位置左边最高就是自己
    for i := 1; i < n; i++ {
        leftMax[i] = max(leftMax[i-1], height[i])  // 递推关系
    }

    // 预处理右边最大高度
    rightMax := make([]int, n)
    rightMax[n-1] = height[n-1]  // 边界条件：最后一个位置右边最高就是自己
    for i := n - 2; i >= 0; i-- {
        rightMax[i] = max(rightMax[i+1], height[i])  // 递推关系
    }

    // 计算每个位置的接水量
    result := 0
    for i := 1; i < n-1; i++ {  // 边界：首尾位置不能接水
        water := min(leftMax[i], rightMax[i]) - height[i] // 接水高度
        if water > 0 {
            result += water
        }
    }

    return result
}
```

#### 演绎法解释每一步

```go
// 第1步：预处理左边最大高度（演绎：从左到右累积信息）
leftMax[0] = height[0]
for i := 1; i < n; i++ {
    // 演绎推理：位置i左边最高 = max(位置i-1左边最高, 位置i本身高度)
    leftMax[i] = max(leftMax[i-1], height[i])
}

// 第2步：预处理右边最大高度（演绎：从右到左累积信息）
rightMax[n-1] = height[n-1]
for i := n - 2; i >= 0; i-- {
    // 演绎推理：位置i右边最高 = max(位置i+1右边最高, 位置i本身高度)
    rightMax[i] = max(rightMax[i+1], height[i])
}

// 第3步：计算结果（演绎：应用第一原理公式）
for i := 1; i < n-1; i++ {
    // 演绎推理：接水量 = min(左边最高, 右边最高) - 地面高度
    water := min(leftMax[i], rightMax[i]) - height[i]
    result += water
}
```

---

## 🎮 完整演绎分析示例

### **输入：[4, 2, 0, 3, 2, 5]**

#### **第1步：演绎预处理左边最大高度**

```
演绎过程：
i=0: leftMax[0] = height[0] = 4
i=1: leftMax[1] = max(leftMax[0], height[1]) = max(4, 2) = 4
i=2: leftMax[2] = max(leftMax[1], height[2]) = max(4, 0) = 4
i=3: leftMax[3] = max(leftMax[2], height[3]) = max(4, 3) = 4
i=4: leftMax[4] = max(leftMax[3], height[4]) = max(4, 2) = 4
i=5: leftMax[5] = max(leftMax[4], height[5]) = max(4, 5) = 5

结果：leftMax = [4, 4, 4, 4, 4, 5]
```

#### **第2步：演绎预处理右边最大高度**

```
演绎过程：
i=5: rightMax[5] = height[5] = 5
i=4: rightMax[4] = max(rightMax[5], height[4]) = max(5, 2) = 5
i=3: rightMax[3] = max(rightMax[4], height[3]) = max(5, 3) = 5
i=2: rightMax[2] = max(rightMax[3], height[2]) = max(5, 0) = 5
i=1: rightMax[1] = max(rightMax[2], height[1]) = max(5, 2) = 5
i=0: rightMax[0] = max(rightMax[1], height[0]) = max(5, 4) = 5

结果：rightMax = [5, 5, 5, 5, 5, 5]
```

#### **第3步：演绎计算接水量**

```
演绎应用第一原理：
water[i] = min(leftMax[i], rightMax[i]) - height[i]

i=1: min(4,5) - 2 = 4 - 2 = 2
i=2: min(4,5) - 0 = 4 - 0 = 4
i=3: min(4,5) - 3 = 4 - 3 = 1
i=4: min(4,5) - 2 = 4 - 2 = 2

总接水量：2 + 4 + 1 + 2 = 9 ✓
```

---

## 💡 演绎法的优势体现

### **逻辑严密性**
```
每一步都有明确的数学依据：
1. leftMax[i] = max(leftMax[i-1], height[i]) ✅
2. rightMax[i] = max(rightMax[i+1], height[i]) ✅
3. water[i] = min(leftMax[i], rightMax[i]) - height[i] ✅
```

### **可验证性**
```
可以通过小例子验证每个步骤：
- [2,0,2] → water[1] = min(2,2)-0 = 2 ✓
- [3,0,2] → water[1] = min(3,2)-0 = 2 ✓
- [1,0,1] → water[1] = min(1,1)-0 = 1 ✓
```

### **普适性**
```
推导出的公式对任意输入都成立：
- 递增数组：[1,2,3,4] → 接水量为0 ✓
- 递减数组：[4,3,2,1] → 接水量为0 ✓
- 随机数组：[4,2,0,3,2,5] → 接水量为9 ✓
```

---

## 🚀 复杂度分析（演绎推导）

### **时间复杂度分析**
```
第1步：预处理左边 → O(n)
第2步：预处理右边 → O(n)
第3步：计算结果  → O(n)
总计时间复杂度：O(n) ✅
```

### **空间复杂度分析**
```
leftMax数组：O(n)
rightMax数组：O(n)
总计空间复杂度：O(n) ✅
```

### **优化可能性**
```
观察：计算water[i]时只需要leftMax[i]和rightMax[i]
可以用滚动数组优化，但会损失代码可读性
当前方案在时间和空间上都达到了最优（O(n)）
```

---

## 🌟 小白理解技巧

### **生活比喻**
```
想象你在每个位置挖坑：
1. 先看左边最高的柱子（决定了西边的墙有多高）
2. 再看右边最高的柱子（决定了东边的墙有多高）
3. 坑能装多深的水？取两个墙中较矮的那个
4. 减去坑底的高度，就是能装多少水
5. 所有坑的水加起来，就是总接水量
```

### **记忆公式**
```
核心公式：water[i] = min(左边最高, 右边最高) - 当前高度

记忆口诀：
"两边最高取较小，减去当前高度差"
```

### **三步记忆法**
```
1. 预处理左边（从左到右记录最高）
2. 预处理右边（从右到左记录最高）
3. 计算结果（查表相减求和）
```

---

## 📊 对比其他方法

| 方法 | 时间复杂度 | 空间复杂度 | 理解难度 | 演绎推导难度 |
|------|------------|------------|----------|-------------|
| 暴力法 | O(n²) | O(1) | 简单 | 中等 |
| **动态规划** | **O(n)** | **O(n)** | **中等** | **简单** |
| 单调栈 | O(n) | O(n) | 较难 | 中等 |
| 双指针 | O(n) | O(1) | 较难 | 较难 |

**动态规划的优势：**
- 演绎推导最直观
- 逻辑最清晰
- 最容易验证和调试
- 适合教学和理解

---

## 🎯 演绎法总结

### **核心思想**
> **"动态规划 = 预处理所有信息 + 应用物理原理"**

就像天气预报：
1. 预先收集各地气温数据（预处理）
2. 根据物理定律计算天气（应用原理）
3. 得到准确的天气预报（最终结果）

### **学习价值**
通过演绎法学习动态规划：
- 理解了问题的本质原理
- 掌握了通用的分析方法
- 能够推导和验证算法
- 为解决复杂问题打下基础

**记住：动态规划的核心不是背诵算法，而是理解每一步的数学和物理原理！** 🎉