# é“¾è¡¨å®Œå…¨æŒ‡å— - ä»å…¥é—¨åˆ°ç²¾é€š

## ğŸ“š é“¾è¡¨åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯é“¾è¡¨ï¼Ÿ
é“¾è¡¨æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œç”±ä¸€ç³»åˆ—èŠ‚ç‚¹ç»„æˆï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ï¼š
- **æ•°æ®åŸŸ**ï¼šå­˜å‚¨èŠ‚ç‚¹çš„å€¼
- **æŒ‡é’ˆåŸŸ**ï¼šæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨

### ä¸æ•°ç»„çš„å¯¹æ¯”

| ç‰¹æ€§ | æ•°ç»„ | é“¾è¡¨ |
|------|------|------|
| **å†…å­˜å­˜å‚¨** | è¿ç»­å†…å­˜ç©ºé—´ | åˆ†æ•£å†…å­˜ç©ºé—´ |
| **è®¿é—®æ—¶é—´** | O(1) éšæœºè®¿é—® | O(n) é¡ºåºè®¿é—® |
| **æ’å…¥/åˆ é™¤** | O(n) éœ€è¦ç§»åŠ¨å…ƒç´  | O(1) åªéœ€æ”¹å˜æŒ‡é’ˆ |
| **ç©ºé—´å¤§å°** | å›ºå®šå¤§å°ï¼Œå¯èƒ½æµªè´¹ | åŠ¨æ€å¤§å°ï¼ŒæŒ‰éœ€åˆ†é… |
| **ç¼“å­˜å‹å¥½** | âœ… è¿ç»­å­˜å‚¨ | âŒ åˆ†æ•£å­˜å‚¨ |

## ğŸ”— é“¾è¡¨ç±»å‹è¯¦è§£

### 1. å•å‘é“¾è¡¨ (Singly Linked List)

```go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

**ç‰¹ç‚¹**ï¼š
- åªèƒ½å•å‘éå†
- æ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªæŒ‡é’ˆ
- æœ€åŸºç¡€çš„é“¾è¡¨ç»“æ„

### 2. åŒå‘é“¾è¡¨ (Doubly Linked List)

```go
type DoublyListNode struct {
    Val  int
    Prev *DoublyListNode
    Next *DoublyListNode
}
```

**ç‰¹ç‚¹**ï¼š
- å¯ä»¥åŒå‘éå†
- æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼ˆå‰é©±å’Œåç»§ï¼‰
- æ’å…¥åˆ é™¤æ›´çµæ´»ï¼Œä½†å ç”¨æ›´å¤šç©ºé—´

### 3. å¾ªç¯é“¾è¡¨ (Circular Linked List)

```go
type CircularListNode struct {
    Val  int
    Next *CircularListNode
}
```

**ç‰¹ç‚¹**ï¼š
- å°¾èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹
- å½¢æˆç¯çŠ¶ç»“æ„
- é€‚åˆéœ€è¦å¾ªç¯è®¿é—®çš„åœºæ™¯

### 4. é™æ€é“¾è¡¨ (Static Linked List)

```go
type StaticListNode struct {
    Data int
    Next int  // å­˜å‚¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æ•°ç»„ç´¢å¼•
}

type StaticLinkedList struct {
    Nodes []StaticListNode
    Head  int
}
```

**ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨æ•°ç»„å®ç°é“¾è¡¨
- é€‚åˆå†…å­˜å—é™çš„ç¯å¢ƒ
- ä¸éœ€è¦åŠ¨æ€å†…å­˜åˆ†é…

## ğŸš€ é“¾è¡¨è§£å†³çš„æ ¸å¿ƒé—®é¢˜

### 1. **åŠ¨æ€æ•°æ®å­˜å‚¨**
**é—®é¢˜**ï¼šæ•°ç»„å¤§å°å›ºå®šï¼Œæ— æ³•åŠ¨æ€æ‰©å±•
**é“¾è¡¨è§£å†³**ï¼šå¯ä»¥éšæ—¶æ’å…¥ã€åˆ é™¤ï¼ŒæŒ‰éœ€åˆ†é…å†…å­˜

```go
// å®é™…åº”ç”¨ï¼šéŸ³ä¹æ’­æ”¾åˆ—è¡¨
type SongNode struct {
    title  string
    artist string
    next   *SongNode
    prev   *SongNode
}

type Playlist struct {
    head    *SongNode
    tail    *SongNode
    current *SongNode
    size    int
}

func (p *Playlist) AddSong(title, artist string) {
    newNode := &SongNode{title: title, artist: artist}
    if p.tail == nil {
        p.head = p.tail = newNode
    } else {
        p.tail.next = newNode
        newNode.prev = p.tail
        p.tail = newNode
    }
    p.size++
}

// O(1) æ—¶é—´åˆ é™¤å½“å‰æ­Œæ›²
func (p *Playlist) RemoveCurrent() {
    if p.current != nil {
        if p.current.prev != nil {
            p.current.prev.next = p.current.next
        } else {
            p.head = p.current.next
        }
        if p.current.next != nil {
            p.current.next.prev = p.current.prev
        } else {
            p.tail = p.current.prev
        }
        p.current = p.current.next
        p.size--
    }
}
```

### 2. **é«˜æ•ˆçš„æ’å…¥åˆ é™¤æ“ä½œ**
**é—®é¢˜**ï¼šæ•°ç»„æ’å…¥åˆ é™¤éœ€è¦ç§»åŠ¨å¤§é‡å…ƒç´  O(n)
**é“¾è¡¨è§£å†³**ï¼šåªéœ€ä¿®æ”¹æŒ‡é’ˆ O(1)

```go
// å®é™…åº”ç”¨ï¼šæµè§ˆå™¨å†å²è®°å½•
type PageNode struct {
    url       string
    title     string
    timestamp time.Time
    next      *PageNode
    prev      *PageNode
}

type BrowserHistory struct {
    currentPage *PageNode
    maxSize     int
    size        int
}

// O(1) æ—¶é—´æ·»åŠ æ–°é¡µé¢
func (b *BrowserHistory) VisitPage(url, title string) {
    newNode := &PageNode{
        url:       url,
        title:     title,
        timestamp: time.Now(),
    }

    if b.currentPage != nil {
        b.currentPage.next = newNode
        newNode.prev = b.currentPage
    }
    b.currentPage = newNode
    b.size++

    // é™åˆ¶å†å²è®°å½•å¤§å°
    if b.size > b.maxSize {
        b.removeOldest()
    }
}
```

### 3. **å®ç°æ ˆå’Œé˜Ÿåˆ—**
**é—®é¢˜**ï¼šéœ€è¦LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰æˆ–FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰ç»“æ„
**é“¾è¡¨è§£å†³**ï¼šå¤©ç„¶æ”¯æŒè¿™ä¸¤ç§æ“ä½œæ¨¡å¼

```go
// å®é™…åº”ç”¨ï¼šä»»åŠ¡é˜Ÿåˆ—ç³»ç»Ÿ
type Task struct {
    ID       int
    Name     string
    Priority int
    Data     interface{}
}

type TaskNode struct {
    task *Task
    next *TaskNode
}

type TaskQueue struct {
    front *TaskNode  // é˜Ÿå¤´
    rear  *TaskNode  // é˜Ÿå°¾
    size  int
}

// O(1) æ—¶é—´å…¥é˜Ÿ
func (q *TaskQueue) Enqueue(task *Task) {
    newNode := &TaskNode{task: task}
    if q.rear == nil {
        q.front = q.rear = newNode
    } else {
        q.rear.next = newNode
        q.rear = newNode
    }
    q.size++
}

// O(1) æ—¶é—´å‡ºé˜Ÿ
func (q *TaskQueue) Dequeue() *Task {
    if q.front == nil {
        return nil
    }

    task := q.front.task
    q.front = q.front.next
    if q.front == nil {
        q.rear = nil
    }
    q.size--
    return task
}
```

### 4. **å®ç°LRUç¼“å­˜**
**é—®é¢˜**ï¼šéœ€è¦å¿«é€ŸçŸ¥é“æœ€è¿‘ä½¿ç”¨çš„å…ƒç´ ï¼Œè‡ªåŠ¨æ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„
**é“¾è¡¨è§£å†³**ï¼šåŒå‘é“¾è¡¨ + å“ˆå¸Œè¡¨çš„å®Œç¾ç»“åˆ

```go
// å®é™…åº”ç”¨ï¼šç¼“å­˜ç³»ç»Ÿ
type CacheEntry struct {
    key   string
    value interface{}
    size  int
}

type DLinkedNode struct {
    entry *CacheEntry
    prev  *DLinkedNode
    next  *DLinkedNode
}

type LRUCache struct {
    capacity int64       // æœ€å¤§å®¹é‡
    used     int64       // å·²ä½¿ç”¨å®¹é‡
    cache    map[string]*DLinkedNode
    head     *DLinkedNode  // æœ€è¿‘ä½¿ç”¨ï¼ˆå¤´éƒ¨ï¼‰
    tail     *DLinkedNode  // æœ€ä¹…æœªä½¿ç”¨ï¼ˆå°¾éƒ¨ï¼‰
}

func (c *LRUCache) Get(key string) (interface{}, bool) {
    if node, ok := c.cache[key]; ok {
        c.moveToHead(node)  // ç§»åˆ°å¤´éƒ¨è¡¨ç¤ºæœ€è¿‘ä½¿ç”¨
        return node.entry.value, true
    }
    return nil, false
}

func (c *LRUCache) Put(key string, value interface{}, size int64) {
    if node, ok := c.cache[key]; ok {
        // æ›´æ–°ç°æœ‰èŠ‚ç‚¹
        c.used -= int64(node.entry.size)
        node.entry.value = value
        node.entry.size = size
        c.used += size
        c.moveToHead(node)
    } else {
        // æ·»åŠ æ–°èŠ‚ç‚¹
        newNode := &DLinkedNode{
            entry: &CacheEntry{key: key, value: value, size: size},
        }

        if c.used+size > c.capacity {
            c.evictLRU()  // æ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„
        }

        c.cache[key] = newNode
        c.addToHead(newNode)
        c.used += size
    }
}
```

### 5. **å®ç°å“ˆå¸Œè¡¨çš„å†²çªè§£å†³**
**é—®é¢˜**ï¼šå¤šä¸ªkeyæ˜ å°„åˆ°åŒä¸€ä¸ªå“ˆå¸Œæ¡¶
**é“¾è¡¨è§£å†³**ï¼šæ¯ä¸ªæ¡¶ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨å­˜å‚¨å†²çªçš„å…ƒç´ 

```go
// å®é™…åº”ç”¨ï¼šè‡ªå®šä¹‰å“ˆå¸Œè¡¨
type HashEntry struct {
    key   string
    value interface{}
}

type HashNode struct {
    entry *HashEntry
    next  *HashNode
}

type HashTable struct {
    buckets []*HashNode
    size    int
    capacity int
}

func (h *HashTable) Put(key string, value interface{}) {
    index := h.hash(key) % h.capacity

    // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨
    current := h.buckets[index]
    for current != nil {
        if current.entry.key == key {
            current.entry.value = value
            return
        }
        current = current.next
    }

    // æ’å…¥æ–°èŠ‚ç‚¹åˆ°é“¾è¡¨å¤´éƒ¨
    newNode := &HashNode{
        entry: &HashEntry{key: key, value: value},
        next:  h.buckets[index],
    }
    h.buckets[index] = newNode
    h.size++
}

func (h *HashTable) Get(key string) (interface{}, bool) {
    index := h.hash(key) % h.capacity
    current := h.buckets[index]

    for current != nil {
        if current.entry.key == key {
            return current.entry.value, true
        }
        current = current.next
    }

    return nil, false
}
```

### 6. **å®ç°å›¾ç»“æ„çš„é‚»æ¥è¡¨**
**é—®é¢˜**ï¼šå›¾éœ€è¦è¡¨ç¤ºé¡¶ç‚¹ä¹‹é—´çš„è¿æ¥å…³ç³»
**é“¾è¡¨è§£å†³**ï¼šæ¯ä¸ªé¡¶ç‚¹ç»´æŠ¤ä¸€ä¸ªé‚»æ¥é“¾è¡¨

```go
// å®é™…åº”ç”¨ï¼šç¤¾äº¤ç½‘ç»œ
type Vertex struct {
    ID     string
    Name   string
    Edges  *EdgeNode
}

type EdgeNode struct {
    ToVertex *Vertex
    Weight   float64
    Next     *EdgeNode
}

type Graph struct {
    Vertices map[string]*Vertex
    EdgeCount int
}

func (g *Graph) AddEdge(fromID, toID string, weight float64) {
    fromVertex := g.Vertices[fromID]
    toVertex := g.Vertices[toID]

    // O(1) æ—¶é—´æ·»åŠ è¾¹
    newEdge := &EdgeNode{
        ToVertex: toVertex,
        Weight:   weight,
    }
    newEdge.Next = fromVertex.Edges
    fromVertex.Edges = newEdge
}

func (g *Graph) FindFriends(userID string) []*Vertex {
    user := g.Vertices[userID]
    var friends []*Vertex

    // O(æœ‹å‹æ•°é‡) æ—¶é—´éå†é‚»æ¥è¡¨
    current := user.Edges
    for current != nil {
        friends = append(friends, current.ToVertex)
        current = current.Next
    }

    return friends
}
```

### 7. **å®ç°æ“ä½œç³»ç»Ÿçš„è¿›ç¨‹è°ƒåº¦**
**é—®é¢˜**ï¼šéœ€è¦ç®¡ç†å¤šä¸ªè¿›ç¨‹çš„çŠ¶æ€å’Œé˜Ÿåˆ—
**é“¾è¡¨è§£å†³**ï¼šä½¿ç”¨ä¸åŒé“¾è¡¨ç®¡ç†ä¸åŒçŠ¶æ€çš„è¿›ç¨‹

```go
// å®é™…åº”ç”¨ï¼šè¿›ç¨‹è°ƒåº¦å™¨
type Process struct {
    ID        int
    PID       int
    State     string  // "ready", "running", "blocked"
    Priority  int
    CPU       int
}

type ProcessNode struct {
    Process *Process
    Next    *ProcessNode
    Prev    *ProcessNode  // åŒå‘é“¾è¡¨ï¼Œä¾¿äºåˆ é™¤
}

type Scheduler struct {
    ReadyQueue   *ProcessQueue  // å°±ç»ªé˜Ÿåˆ—
    RunningList  *ProcessList  // è¿è¡Œä¸­çš„è¿›ç¨‹
    BlockedQueue *ProcessQueue  // é˜»å¡é˜Ÿåˆ—
}

type ProcessQueue struct {
    Front *ProcessNode
    Rear  *ProcessNode
    Size  int
}

func (s *Scheduler) AddProcess(p *Process) {
    newNode := &ProcessNode{Process: p}

    switch p.State {
    case "ready":
        s.ReadyQueue.Enqueue(newNode)  // O(1) å…¥é˜Ÿ
    case "running":
        s.RunningList.Append(newNode)  // O(1) æ·»åŠ 
    case "blocked":
        s.BlockedQueue.Enqueue(newNode) // O(1) å…¥é˜Ÿ
    }
}

func (s *Scheduler) ScheduleNext() *Process {
    if s.ReadyQueue.Size > 0 {
        // ä»å°±ç»ªé˜Ÿåˆ—é€‰æ‹©æœ€é«˜ä¼˜å…ˆçº§è¿›ç¨‹
        node := s.selectHighestPriority()

        // O(1) æ—¶é—´ç§»åŠ¨è¿›ç¨‹åˆ°è¿è¡ŒçŠ¶æ€
        s.ReadyQueue.Remove(node)
        node.Process.State = "running"
        s.RunningList.Append(node)

        return node.Process
    }
    return nil
}
```

### 8. **å®ç°ç½‘ç»œåè®®çš„æ•°æ®åŒ…é˜Ÿåˆ—**
**é—®é¢˜**ï¼šç½‘ç»œæ•°æ®åŒ…æŒ‰åˆ°è¾¾é¡ºåºå¤„ç†ï¼Œéœ€è¦é«˜æ•ˆç®¡ç†
**é“¾è¡¨è§£å†³**ï¼šFIFOé˜Ÿåˆ—ç®¡ç†æ•°æ®åŒ…

```go
// å®é™…åº”ç”¨ï¼šç½‘ç»œæœåŠ¡å™¨
type Packet struct {
    Data      []byte
    SeqNum    int
    Timestamp time.Time
    SourceIP  string
    DestIP    string
}

type PacketNode struct {
    Packet *Packet
    Next    *PacketNode
}

type PacketQueue struct {
    Head      *PacketNode
    Tail      *PacketNode
    Size      int64
    MaxSize   int64
    Mutex     sync.Mutex
}

func (q *PacketQueue) Enqueue(packet *Packet) error {
    q.Mutex.Lock()
    defer q.Mutex.Unlock()

    if q.Size >= q.MaxSize {
        return errors.New("queue is full")
    }

    newNode := &PacketNode{Packet: packet}

    if q.Tail == nil {
        q.Head = q.Tail = newNode
    } else {
        q.Tail.Next = newNode
        q.Tail = newNode
    }

    q.Size++
    return nil
}

func (q *PacketQueue) Dequeue() *Packet {
    q.Mutex.Lock()
    defer q.Mutex.Unlock()

    if q.Head == nil {
        return nil
    }

    packet := q.Head.Packet
    q.Head = q.Head.Next

    if q.Head == nil {
        q.Tail = nil
    }

    q.Size--
    return packet
}
```

## ğŸ¯ é“¾è¡¨é€‰æ‹©çš„å†³ç­–æ ‡å‡†

### ä»€ä¹ˆæ—¶å€™é€‰æ‹©é“¾è¡¨ï¼Ÿ

| åœºæ™¯ | é“¾è¡¨ä¼˜åŠ¿ | æ›¿ä»£æ–¹æ¡ˆ |
|------|----------|----------|
| **é¢‘ç¹æ’å…¥åˆ é™¤** | O(1) æ—¶é—´å¤æ‚åº¦ | æ•°ç»„O(n) |
| **åŠ¨æ€å¤§å°éœ€æ±‚** | æŒ‰éœ€åˆ†é…å†…å­˜ | æ•°ç»„éœ€æ‰©å®¹ |
| **å®ç°æ ˆé˜Ÿåˆ—** | å¤©ç„¶æ”¯æŒ | å¯ç”¨æ•°ç»„å®ç° |
| **å†…å­˜è¦æ±‚ä¸¥æ ¼** | ç²¾ç¡®ä½¿ç”¨ | æ•°ç»„å¯èƒ½æµªè´¹ |
| **è¡¨ç¤ºå…³ç³»å›¾** | é‚»æ¥è¡¨è‡ªç„¶è¡¨è¾¾ | é‚»æ¥çŸ©é˜µ |

### ä»€ä¹ˆæ—¶å€™é¿å…é“¾è¡¨ï¼Ÿ

| åœºæ™¯ | é“¾è¡¨åŠ£åŠ¿ | æ¨èæ–¹æ¡ˆ |
|------|----------|----------|
| **éœ€è¦éšæœºè®¿é—®** | O(n) é¡ºåºæŸ¥æ‰¾ | æ•°ç»„O(1) |
| **ç¼“å­˜æ€§èƒ½é‡è¦** | åˆ†æ•£å†…å­˜è®¿é—® | æ•°ç»„è¿ç»­å­˜å‚¨ |
| **æ•°æ®é‡è¾ƒå°** | æŒ‡é’ˆå¼€é”€ç›¸å¯¹å¤§ | æ•°ç»„æ›´ç®€å• |
| **å›ºå®šæ•°æ®é›†** | åŠ¨æ€å†…å­˜æ— ä¼˜åŠ¿ | é™æ€æ•°ç»„æ›´é«˜æ•ˆ |

## ğŸ’¡ é“¾è¡¨è®¾è®¡çš„æœ€ä½³å®è·µ

### 1. **å“¨å…µèŠ‚ç‚¹æ¨¡å¼**
```go
// é¿å…ç©ºæŒ‡é’ˆæ£€æŸ¥ï¼Œç®€åŒ–è¾¹ç•Œå¤„ç†
func InsertAfter(head *ListNode, target, val int) *ListNode {
    dummy := &ListNode{Next: head}
    prev := dummy

    for prev.Next != nil && prev.Next.Val != target {
        prev = prev.Next
    }

    if prev.Next != nil {
        newNode := &ListNode{Val: val, Next: prev.Next.Next}
        prev.Next.Next = newNode
    }

    return dummy.Next
}
```

### 2. **å¤´å°¾æŒ‡é’ˆä¼˜åŒ–**
```go
// O(1) æ—¶é—´çš„å¤´éƒ¨å’Œå°¾éƒ¨æ“ä½œ
type OptimizedList struct {
    Head *ListNode
    Tail *ListNode
    Size int
}

func (l *OptimizedList) Append(val int) {
    newNode := &ListNode{Val: val}

    if l.Tail == nil {
        l.Head = l.Tail = newNode
    } else {
        l.Tail.Next = newNode
        l.Tail = newNode
    }
    l.Size++
}
```

### 3. **åŒå‘é“¾è¡¨çš„ä¼˜åŠ¿**
```go
// æ”¯æŒO(1)æ—¶é—´çš„åˆ é™¤æ“ä½œï¼ˆç»™å®šèŠ‚ç‚¹å¼•ç”¨ï¼‰
type DoublyNode struct {
    Val  int
    Prev *DoublyNode
    Next *DoublyNode
}

func (n *DoublyNode) Remove() {
    if n.Prev != nil {
        n.Prev.Next = n.Next
    }
    if n.Next != nil {
        n.Next.Prev = n.Prev
    }
    // æ¸…ç†æŒ‡é’ˆï¼Œé¿å…å†…å­˜æ³„æ¼
    n.Prev = nil
    n.Next = nil
}
```

## ğŸš€ æ€»ç»“

é“¾è¡¨åœ¨å®é™…å¼€å‘ä¸­ä¸»è¦è§£å†³ï¼š

1. **åŠ¨æ€æ•°æ®ç®¡ç†**ï¼šéŸ³ä¹æ’­æ”¾åˆ—è¡¨ã€æµè§ˆå™¨å†å²ã€ä»»åŠ¡é˜Ÿåˆ—
2. **é«˜æ•ˆæ’å…¥åˆ é™¤**ï¼šæ–‡æœ¬ç¼–è¾‘å™¨ã€ç¼“å­˜ç³»ç»Ÿã€è¿›ç¨‹è°ƒåº¦
3. **å®ç°æŠ½è±¡æ•°æ®ç±»å‹**ï¼šæ ˆã€é˜Ÿåˆ—ã€é›†åˆã€æ˜ å°„è¡¨
4. **è¡¨ç¤ºå…³ç³»ç»“æ„**ï¼šå›¾çš„é‚»æ¥è¡¨ã€æ ‘çš„å­èŠ‚ç‚¹åˆ—è¡¨
5. **ç³»ç»Ÿçº§åº”ç”¨**ï¼šç½‘ç»œç¼“å†²ã€å†…å­˜ç®¡ç†ã€æ–‡ä»¶ç³»ç»Ÿ

**æ ¸å¿ƒæ¦‚å¿µ**ï¼šé€šè¿‡ç®€å•çš„æŒ‡é’ˆæ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºå¤æ‚è€Œé«˜æ•ˆçš„æ•°æ®ç»“æ„ï¼Œè¿™æ˜¯è®¡ç®—æœºç§‘å­¦çš„åŸºç¡€ï¼

## ğŸ› ï¸ æ ¸å¿ƒæ“ä½œè¯¦è§£

### 1. æ’å…¥æ“ä½œ

#### åœ¨å¤´éƒ¨æ’å…¥
```go
func InsertAtHead(head *ListNode, val int) *ListNode {
    newNode := &ListNode{Val: val, Next: head}
    return newNode
}
```

#### åœ¨å°¾éƒ¨æ’å…¥
```go
func InsertAtTail(head *ListNode, val int) *ListNode {
    newNode := &ListNode{Val: val}

    if head == nil {
        return newNode
    }

    current := head
    for current.Next != nil {
        current = current.Next
    }

    current.Next = newNode
    return head
}
```

#### åœ¨æŒ‡å®šä½ç½®æ’å…¥
```go
func InsertAtIndex(head *ListNode, index, val int) *ListNode {
    if index == 0 {
        return InsertAtHead(head, val)
    }

    current := head
    for i := 0; current != nil && i < index-1; i++ {
        current = current.Next
    }

    if current == nil {
        return head  // ç´¢å¼•è¶…å‡ºèŒƒå›´
    }

    newNode := &ListNode{Val: val, Next: current.Next}
    current.Next = newNode
    return head
}
```

### 2. åˆ é™¤æ“ä½œ

#### åˆ é™¤å¤´èŠ‚ç‚¹
```go
func DeleteHead(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    return head.Next
}
```

#### åˆ é™¤å°¾èŠ‚ç‚¹
```go
func DeleteTail(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }

    current := head
    for current.Next.Next != nil {
        current = current.Next
    }

    current.Next = nil
    return head
}
```

#### åˆ é™¤æŒ‡å®šå€¼çš„èŠ‚ç‚¹
```go
func DeleteValue(head *ListNode, val int) *ListNode {
    // åˆ é™¤å¤´èŠ‚ç‚¹
    if head != nil && head.Val == val {
        return head.Next
    }

    current := head
    for current != nil && current.Next != nil {
        if current.Next.Val == val {
            current.Next = current.Next.Next
            break
        }
        current = current.Next
    }

    return head
}
```

## ğŸ¯ é«˜çº§ç®—æ³•æŠ€å·§

### 1. å¿«æ…¢æŒ‡é’ˆæŠ€æœ¯

**åº”ç”¨åœºæ™¯**ï¼šå¯»æ‰¾é“¾è¡¨ä¸­ç‚¹ã€æ£€æµ‹ç¯ã€åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹

#### å¯»æ‰¾é“¾è¡¨ä¸­ç‚¹
```go
func FindMiddle(head *ListNode) *ListNode {
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    return slow
}
```

#### æ£€æµ‹ç¯
```go
func HasCycle(head *ListNode) bool {
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true
        }
    }

    return false
}
```

#### åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹
```go
func RemoveNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    slow, fast := dummy, dummy

    // fast å…ˆèµ°næ­¥
    for i := 0; i < n; i++ {
        fast = fast.Next
    }

    // ä¸€èµ·èµ°ï¼Œç›´åˆ°faståˆ°è¾¾æœ«å°¾
    for fast.Next != nil {
        slow = slow.Next
        fast = fast.Next
    }

    // åˆ é™¤slow.Next
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

### 2. å“¨å…µèŠ‚ç‚¹æŠ€æœ¯

**ç”¨é€”**ï¼šç®€åŒ–è¾¹ç•Œæ¡ä»¶å¤„ç†

```go
func DeleteDuplicates(head *ListNode) *ListNode {
    dummy := &ListNode{Next: head}
    prev := dummy

    for head != nil && head.Next != nil {
        if head.Val == head.Next.Val {
            // æ‰¾åˆ°é‡å¤æ®µ
            duplicateVal := head.Val
            for head != nil && head.Val == duplicateVal {
                head = head.Next
            }
            prev.Next = head
        } else {
            prev = prev.Next
            head = head.Next
        }
    }

    return dummy.Next
}
```

### 3. é“¾è¡¨åˆå¹¶æŠ€æœ¯

#### åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
```go
func MergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }

    if l1 != nil {
        current.Next = l1
    } else {
        current.Next = l2
    }

    return dummy.Next
}
```

## ğŸ§© ç»å…¸é¢è¯•é¢˜

### 1. åè½¬é“¾è¡¨ç³»åˆ—

#### å®Œå…¨åè½¬ï¼ˆå·²å®ç°ï¼‰
#### åè½¬éƒ¨åˆ†é“¾è¡¨ï¼ˆå·²å®ç°ï¼‰
#### ä¸¤ä¸¤åè½¬é“¾è¡¨
```go
func SwapPairs(head *ListNode) *ListNode {
    dummy := &ListNode{Next: head}
    prev := dummy

    for prev.Next != nil && prev.Next.Next != nil {
        first := prev.Next
        second := prev.Next.Next

        // äº¤æ¢
        prev.Next = second
        first.Next = second.Next
        second.Next = first

        // ç§»åŠ¨prevæŒ‡é’ˆ
        prev = first
    }

    return dummy.Next
}
```

### 2. å›æ–‡é“¾è¡¨æ£€æµ‹

```go
func IsPalindrome(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return true
    }

    // æ‰¾åˆ°ä¸­ç‚¹
    middle := FindMiddle(head)

    // åè½¬ååŠéƒ¨åˆ†
    reverseSecondHalf := ReverseList(middle)

    // æ¯”è¾ƒ
    result := true
    first := head
    second := reverseSecondHalf
    for second != nil {
        if first.Val != second.Val {
            result = false
            break
        }
        first = first.Next
        second = second.Next
    }

    // æ¢å¤é“¾è¡¨ï¼ˆå¯é€‰ï¼‰
    middle.Next = ReverseList(reverseSecondHalf)

    return result
}
```

### 3. é“¾è¡¨æ’åº

#### é“¾è¡¨å½’å¹¶æ’åº
```go
func SortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    // åˆ†å‰²é“¾è¡¨
    mid := FindMiddle(head)
    left := head
    right := mid.Next
    mid.Next = nil

    // é€’å½’æ’åº
    left = SortList(left)
    right = SortList(right)

    // åˆå¹¶
    return MergeTwoLists(left, right)
}
```

## ğŸ¨ å®é™…åº”ç”¨åœºæ™¯

### 1. æµè§ˆå™¨å†å²è®°å½•
```go
type BrowserHistory struct {
    current *PageNode
}

type PageNode struct {
    url   string
    prev  *PageNode
    next  *PageNode
}
```

### 2. éŸ³ä¹æ’­æ”¾åˆ—è¡¨
```go
type Playlist struct {
    head    *SongNode
    current *SongNode
    size    int
}

type SongNode struct {
    title    string
    artist   string
    duration time.Duration
    next     *SongNode
    prev     *SongNode
}
```

### 3. æ–‡ä»¶ç³»ç»Ÿ
```go
type FileNode struct {
    name     string
    isDir    bool
    size     int64
    parent   *FileNode
    children []*FileNode
}
```

## âš ï¸ å¸¸è§é™·é˜±å’Œæ³¨æ„äº‹é¡¹

### 1. å†…å­˜æ³„æ¼
```go
// âŒ é”™è¯¯ï¼šå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
func DeleteNodeWrong(node *ListNode) {
    node = node.Next  // åªæ˜¯æ”¹å˜äº†å±€éƒ¨å˜é‡
}

// âœ… æ­£ç¡®ï¼šæ­£ç¡®é‡Šæ”¾å†…å­˜
func DeleteNodeCorrect(head *ListNode, target *ListNode) *ListNode {
    if head == target {
        return head.Next
    }

    current := head
    for current != nil && current.Next != target {
        current = current.Next
    }

    if current != nil {
        current.Next = target.Next
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥é‡Šæ”¾targetèŠ‚ç‚¹çš„å†…å­˜
    }

    return head
}
```

### 2. ç©ºæŒ‡é’ˆæ£€æŸ¥
```go
// âŒ é”™è¯¯ï¼šæ²¡æœ‰ç©ºæŒ‡é’ˆæ£€æŸ¥
func PrintListWrong(head *ListNode) {
    for head.Val != 0 {  // å¦‚æœheadæ˜¯nilä¼šå´©æºƒ
        fmt.Println(head.Val)
        head = head.Next
    }
}

// âœ… æ­£ç¡®ï¼šåŒ…å«ç©ºæŒ‡é’ˆæ£€æŸ¥
func PrintListCorrect(head *ListNode) {
    current := head
    for current != nil {
        fmt.Println(current.Val)
        current = current.Next
    }
}
```

### 3. ç¯å½¢é“¾è¡¨å¤„ç†
```go
// å®‰å…¨çš„é“¾è¡¨éå†ï¼Œé˜²æ­¢æ­»å¾ªç¯
func SafeTraversal(head *ListNode, maxSteps int) {
    current := head
    steps := 0

    for current != nil && steps < maxSteps {
        fmt.Println(current.Val)
        current = current.Next
        steps++
    }

    if steps == maxSteps {
        fmt.Println("è­¦å‘Šï¼šå¯èƒ½å­˜åœ¨ç¯å½¢é“¾è¡¨")
    }
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. æ‰¹é‡æ“ä½œ
```go
// å°†å¤šä¸ªæ“ä½œåˆå¹¶ä¸ºä¸€æ¬¡éå†
func ProcessBatch(head *ListNode, processors []func(*ListNode)) {
    current := head
    for current != nil {
        for _, processor := range processors {
            processor(current)
        }
        current = current.Next
    }
}
```

### 2. å†…å­˜æ± æŠ€æœ¯
```go
type ListNodePool struct {
    pool []*ListNode
}

func (p *ListNodePool) New(val int) *ListNode {
    if len(p.pool) > 0 {
        node := p.pool[len(p.pool)-1]
        p.pool = p.pool[:len(p.pool)-1]
        node.Val = val
        node.Next = nil
        return node
    }

    return &ListNode{Val: val}
}

func (p *ListNodePool) Release(node *ListNode) {
    p.pool = append(p.pool, node)
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å¤‡æ³¨ |
|------|------------|------------|------|
| **è®¿é—®ç¬¬kä¸ªèŠ‚ç‚¹** | O(n) | O(1) | éœ€è¦éå† |
| **å¤´éƒ¨æ’å…¥** | O(1) | O(1) | æœ€å¿« |
| **å°¾éƒ¨æ’å…¥** | O(n) | O(1) | éœ€è¦éå† |
| **ä¸­é—´æ’å…¥** | O(n) | O(1) | éœ€è¦æŸ¥æ‰¾ä½ç½® |
| **åˆ é™¤æ“ä½œ** | O(n) | O(1) | éœ€è¦æŸ¥æ‰¾ |
| **éå†** | O(n) | O(1) | çº¿æ€§è®¿é—® |
| **åè½¬** | O(n) | O(1) | è¿­ä»£æ³• |
| **åˆå¹¶** | O(n) | O(1) | æœ‰åºé“¾è¡¨ |

## ğŸ¯ æ€»ç»“

### ä»€ä¹ˆæ—¶å€™ä½¿ç”¨é“¾è¡¨ï¼Ÿ
- âœ… é¢‘ç¹çš„æ’å…¥åˆ é™¤æ“ä½œ
- âœ… æ•°æ®å¤§å°ä¸ç¡®å®šï¼Œéœ€è¦åŠ¨æ€æ‰©å±•
- âœ… ä¸éœ€è¦éšæœºè®¿é—®çš„åœºæ™¯

### ä»€ä¹ˆæ—¶å€™é¿å…ä½¿ç”¨é“¾è¡¨ï¼Ÿ
- âŒ éœ€è¦é¢‘ç¹éšæœºè®¿é—®
- âŒ å†…å­˜ä½¿ç”¨æå…¶æ•æ„Ÿ
- âŒ ç¼“å­˜æ€§èƒ½è¦æ±‚é«˜çš„åœºæ™¯

### å­¦ä¹ å»ºè®®
1. **æŒæ¡åŸºç¡€æ“ä½œ**ï¼šå¢åˆ æ”¹æŸ¥
2. **ç†Ÿç»ƒæŒ‡é’ˆæ“ä½œ**ï¼šé¿å…ç©ºæŒ‡é’ˆå’Œå†…å­˜æ³„æ¼
3. **ç†è§£é«˜çº§æŠ€å·§**ï¼šå¿«æ…¢æŒ‡é’ˆã€å“¨å…µèŠ‚ç‚¹
4. **å¤šç»ƒä¹ ç»å…¸é¢˜ç›®**ï¼šåè½¬ã€åˆå¹¶ã€æ’åºç­‰
5. **æ³¨æ„è¾¹ç•Œæƒ…å†µ**ï¼šç©ºé“¾è¡¨ã€å•èŠ‚ç‚¹ã€é‡å¤å€¼

é“¾è¡¨æ˜¯ç†è§£æŒ‡é’ˆæ“ä½œå’Œæ•°æ®ç»“æ„çš„åŸºç¡€ï¼ŒæŒæ¡äº†é“¾è¡¨ï¼Œå¯¹å­¦ä¹ æ ‘ã€å›¾ç­‰å¤æ‚æ•°æ®ç»“æ„ä¼šå¾ˆæœ‰å¸®åŠ©ï¼