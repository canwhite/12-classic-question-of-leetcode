# 三数之和算法 - 小白完全指南

## 🎯 问题理解

**题目**：给你一个整数数组，找出所有不重复的三元组 `[a, b, c]`，使得 `a + b + c = 0`

**示例**：
- 输入：`[-1, 0, 1, 2, -1, -4]`
- 输出：`[[-1, -1, 2], [-1, 0, 1]]`

## 🤔 思考过程

### 笨方法（暴力解法）

```go
// 三重循环，把所有可能都试一遍
for i := 0; i < len(nums); i++ {
    for j := i + 1; j < len(nums); j++ {
        for k := j + 1; k < len(nums); k++ {
            if nums[i] + nums[j] + nums[k] == 0 {
                找到了！
            }
        }
    }
}
```

**问题**：太慢了！比如1000个数字需要 1000×999×998 次计算 = 约10亿次！

### 聪明方法（双指针法）

**核心思想**：
1. 先排序（让数字从小到大排好队）
2. 固定一个数字
3. 用两个指针找另外两个数字

## 📊 详细步骤演示

### 第1步：排序

原始数组：`[-1, 0, 1, 2, -1, -4]`

排序后：`[-4, -1, -1, 0, 1, 2]`

**为什么要排序？**
- 方便去重（相同的数字会排在一起）
- 方便使用双指针（从小到大寻找）

### 第2步：固定第一个数（用循环）

```
第1轮：固定 -4
第2轮：固定 -1
第3轮：固定 0
第4轮：固定 1
...
```

### 第3步：双指针找另外两个数

以第一轮为例，固定 `-4`：

```
数组：[-4, -1, -1, 0, 1, 2]
       ^              ^
    固定            右指针
```

设置两个指针：
- **左指针**：从固定数的下一个开始
- **右指针**：从数组末尾开始

```
[-4, -1, -1, 0, 1, 2]
  ^i  ^left        ^right
```

### 第4步：移动指针

计算三个数的和：
- 如果和 = 0：找到了！记录下来，移动两个指针
- 如果和 < 0：说明和太小，需要更大的数，移动左指针（向右）
- 如果和 > 0：说明和太大，需要更小的数，移动右指针（向左）

## 🔍 完整演示过程

### 第1轮：固定 -4

```
数组：[-4, -1, -1, 0, 1, 2]
  ^i    ^left        ^right
  和 = -4 + (-1) + 2 = -3 < 0
  移动左指针 →
```

```
数组：[-4, -1, -1, 0, 1, 2]
  ^i        ^left    ^right
  和 = -4 + (-1) + 2 = -3 < 0
  移动左指针 →
```

```
数组：[-4, -1, -1, 0, 1, 2]
  ^i            ^left ^right
  和 = -4 + 0 + 2 = -2 < 0
  移动左指针 →
```

```
数组：[-4, -1, -1, 0, 1, 2]
  ^i              ^left^right
  和 = -4 + 1 + 2 = -1 < 0
  移动左指针 →
```

现在 left == right，第一轮结束，没有找到和为0的组合。

### 第2轮：固定 -1

```
数组：[-4, -1, -1, 0, 1, 2]
         ^i    ^left     ^right
  和 = -1 + (-1) + 2 = 0 ✓
  找到了：[-1, -1, 2]

  移动两个指针：
  left 向右，right 向左
```

```
数组：[-4, -1, -1, 0, 1, 2]
         ^i        ^left ^right
  和 = -1 + 0 + 1 = 0 ✓
  找到了：[-1, 0, 1]

  移动两个指针
```

现在 left == right，第二轮结束。

### 第3轮：固定第二个 -1

⚠️ **去重逻辑**：发现当前数字 `nums[2] = -1` 和前一个数字 `nums[1] = -1` 相同
- **跳过**这一轮，避免重复结果

### 第4轮：固定 0

```
数组：[-4, -1, -1, 0, 1, 2]
                 ^i  ^left ^right
  和 = 0 + 1 + 2 = 3 > 0
  和太大，移动右指针 ←
```

现在 left == right，第四轮结束。

## 🚨 重要优化技巧

### 1. 去重 - 跳过重复数字

```go
// 如果当前数字和前一个相同，跳过
if i > 0 && nums[i] == nums[i-1] {
    continue
}
```

**为什么？** 避免计算相同的组合：
- `[ -1, 0, 1 ]` 和 `[ -1, 0, 1 ]` 是重复的
- 只计算一次就够了

### 2. 提前终止

```go
// 如果当前数字 > 0，后面不可能有和为0的组合
if nums[i] > 0 {
    break
}
```

**为什么？** 数组已排序：
- 如果第一个数就 > 0
- 那么三个正数相加肯定 > 0
- 不可能找到和为0的组合

### 3. 内层去重

找到一组解后，继续跳过重复元素：

```go
// 跳过重复的左指针元素
for left < right && nums[left] == nums[left+1] {
    left++
}
// 跳过重复的右指针元素
for left < right && nums[right] == nums[right-1] {
    right--
}
```

## 📈 时间复杂度分析

### 暴力解法：O(n³)
- 3层嵌套循环
- n=1000 时约 10⁹ 次运算

### 双指针法：O(n²)
- 外层循环：n 次
- 内层双指针：最多 n 次
- 总共：n × n = n²
- n=1000 时约 10⁶ 次运算

**性能提升：1000倍！**

## 🧮 完整代码解析

```go
func SumThree(nums []int) [][]int {
    sort.Ints(nums) // 步骤1：排序
    var result [][]int
    n := len(nums)

    // 步骤2：外层循环，固定第一个数
    for i := 0; i < n-2; i++ {
        // 技巧1：去重 - 跳过重复数字
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        // 技巧2：提前终止
        if nums[i] > 0 {
            break
        }

        // 步骤3：双指针寻找另外两个数
        left, right := i+1, n-1

        for left < right {
            sum := nums[i] + nums[left] + nums[right]

            if sum == 0 {
                // 找到一组解
                result = append(result, []int{nums[i], nums[left], nums[right]})

                // 技巧3：内层去重
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }

                left++
                right--
            } else if sum < 0 {
                // 和太小，需要更大的数
                left++
            } else {
                // 和太大，需要更小的数
                right--
            }
        }
    }

    return result
}
```

## 🎯 核心思想总结

### 算法的"降维打击"：
- **三维问题**：找3个数的组合 → **O(n³)**
- **降维到二维**：固定1个数，找另外2个数 → **O(n²)**

### 为什么要排序？
1. **去重方便**：相同数字排在一起
2. **双指针可用**：有序数组才能用双指针
3. **提前终止**：可以判断是否还有可能

### 双指针的本质：
- **有序数组中查找两个数**的经典技巧
- 类似二分查找的思想
- 利用有序性减少搜索空间

## 🤔 思考题

### 如果找四数之和怎么办？

思路类似：
1. 排序
2. 固定前两个数（双重循环）
3. 用双指针找后两个数
4. 时间复杂度：O(n³)

### 如果目标不是0，而是任意值target？

只需修改条件：
```go
if sum == target {
    // 找到了
} else if sum < target {
    left++
} else {
    right--
}
```

## 💡 学习建议

1. **先理解暴力解法** - 知道为什么慢
2. **理解降维思想** - 如何从3维降到2维
3. **掌握双指针技巧** - 有序数组中查找的利器
4. **注意边界情况** - 去重、提前终止等细节

这个算法是面试中的高频题，体现了算法优化的核心思想！