# 两数之和算法详解

## 🎯 问题定义

**题目**：给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

**示例**：
- 输入：`nums = [2, 7, 11, 15]`, `target = 9`
- 输出：`[0, 1]`
- 解释：因为 `nums[0] + nums[1] = 2 + 7 = 9`

## 🤔 暴力解法（笨方法）

### 实现代码
```go
func SumBruteForce(nums []int, target int) []int {
    for i := 0; i < len(nums); i++ {
        for j := i + 1; j < len(nums); j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return []int{}
}
```

### 算法分析
- **时间复杂度**：O(n²) - 每个数都要和后面的所有数比较
- **空间复杂度**：O(1) - 没有使用额外空间
- **问题**：数据量大时效率极低，比如10000个数字需要5000万次比较

## 🚀 优化解法（使用HashMap）

### 核心思想
**以空间换时间**：用字典（HashMap）记录已经看过的数字，将查找时间从O(n)降到O(1)

### 🔍 思维转变：反向思考（倒用HashMap）

**常规思维**：
- HashMap存储：`key = 索引`, `value = 数值`
- 这就是数组的自然存储方式：`nums[0] = 2, nums[1] = 7...`
- 查找：需要遍历数组，两两相加比较

**优化思维**：
- HashMap存储：`key = 数值`, `value = 索引`
- 反转存储关系：`{2: 0, 7: 1, 11: 2, 15: 3}`
- 查找：遍历数组，计算需要的值，直接在HashMap中查找

#### 存储方式对比

**方法1：优化存储（key=数值，value=索引）**
```go
func Sum(nums []int, target int) []int {
    numMap := make(map[int]int)  // key: 数字, value: 索引

    for i, num := range nums {
        complement := target - num
        if j, exists := numMap[complement]; exists {
            return []int{j, i}  // 找到匹配
        }
        numMap[num] = i  // 存入字典
    }
    return nil
}
```

**方法2：常规存储（key=索引，value=数值）**
```go
func SumRegular(nums []int, target int) []int {
    // 这就是数组本身的存储方式，不需要额外HashMap
    // nums[0] = 2, nums[1] = 7, nums[2] = 11, nums[3] = 15

    // 只能用暴力解法：两两相加比较
    for i := 0; i < len(nums); i++ {
        for j := i + 1; j < len(nums); j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
```

#### ❌ 为什么常规存储效率低？

**问题分析**：
1. **无法快速查找**：需要O(n²)的双重循环
2. **失去HashMap优势**：无法利用O(1)的查找特性
3. **无法直接计算**：不知道要找的具体值

**原因**：
- 数组天然就是 `key=索引, value=数值` 的存储方式
- 我们需要的是通过**数值**找到**索引**
- 但数组只能通过**索引**找到**数值**，方向反了！

#### ✅ 正确的"反向"思考

**真正的反向思维**不是存储顺序的反向，而是**查找逻辑的反向**：

```go
// 不再是：遍历数组，两两相加比较
// 而是：遍历数组，计算需要什么，直接找那个需要的值
```

#### 思维对比表

| 思维方式 | 存储方式 | 查找策略 | 时间复杂度 | 优势 |
|----------|----------|----------|------------|------|
| **数组原生** | key=索引, value=数值 | 两两相加比较 | O(n²) | 简单直接 |
| **优化存储** | key=数值, value=索引 | 计算complement直接查找 | O(n) | 高效查找 |
| **错误思路** | key=索引, value=数值 | 仍然两两比较 | O(n²) | 无优势 |
| **正确思路** | key=数值, value=索引 | 从"找配对"到"需要什么" | O(n) | 思维转变 |

#### 🧠 面试思维技巧

**问题**：如果数组有重复元素怎么办？

**错误思维**：
```go
// 遇到重复数字就不知道怎么处理了
```

**正确反向思维**：
```go
func SumWithDuplicates(nums []int, target int) [][]int {
    var result [][]int
    numMap := make(map[int][]int)  // 一个数字可能有多个索引

    for i, num := range nums {
        complement := target - num
        if indices, exists := numMap[complement]; exists {
            // 找到所有可能的组合
            for _, j := range indices {
                result = append(result, []int{j, i})
            }
        }
        // 存储当前数字的所有索引
        numMap[num] = append(numMap[num], i)
    }
    return result
}
```

#### 🎯 核心启示

1. **存储结构要服务于查找需求**
   - 如果需要快速通过数值找索引 → key=数值
   - 如果需要快速通过索引找数值 → key=索引

2. **反向思考不是简单的顺序颠倒**
   - 而是从不同的角度解决问题
   - 从"遍历找答案"到"计算需求直接查找"

3. **HashMap的威力在于直接访问**
   - 利用O(1)的查找特性
   - 避免不必要的遍历比较

这种"反向思维"能力是算法面试的重要考察点，体现了你对数据结构本质的理解！

### 实现代码
```go
func Sum(nums []int, target int) []int {
    // 使用map存储已经遍历过的数字及其索引
    // key: 数字, value: 索引
    numMap := make(map[int]int)

    for i, num := range nums {
        // 检查目标数字 - 当前数字是否存在于map中
        complement := target - num
        if j, exists := numMap[complement]; exists {
            // 找到了，返回两个数的索引
            return []int{j, i}
        }

        // 将当前数字存入map，供后续查找使用
        numMap[num] = i
    }

    // 没有找到
    return []int{}
}
```

### 算法分析
- **时间复杂度**：O(n) - 只需要遍历一次数组
- **空间复杂度**：O(n) - 需要额外的HashMap空间

## 📊 一步一步演示

### 示例：`nums = [2, 7, 11, 15]`, `target = 9`

| 轮次 | 当前数字 | complement | HashMap状态 | 是否找到 |
|------|----------|------------|-------------|----------|
| 1 | 2 | 7 | {} → {2:0} | ❌ |
| 2 | 7 | 2 | {2:0} → {2:0, 7:1} | ✅ 找到索引0 |

**详细过程**：
1. **第1轮**：`num = 2`
   - 需要找的数：`9 - 2 = 7`
   - HashMap是空的，没找到7
   - 将2存入HashMap：`{2:0}`

2. **第2轮**：`num = 7`
   - 需要找的数：`9 - 7 = 2`
   - HashMap里有2！找到索引0
   - 返回结果 `[0, 1]`

## 🎮 实际应用场景

### 1. 电商系统 - 凑单功能
```go
// 找两件商品刚好凑满满减门槛
func FindComboItems(items []Product, targetPrice float64) []Product {
    priceMap := make(map[float64]int)

    for i, item := range items {
        complement := targetPrice - item.Price
        if j, exists := priceMap[complement]; exists {
            return []Product{items[j], item}
        }
        priceMap[item.Price] = i
    }
    return nil
}
```

**应用场景**：
- "满200减20"活动
- 找两件商品总价正好等于满减金额
- 实时推荐搭配商品

### 2. 游戏匹配系统
```go
// 玩家战力匹配 - 找到战力值匹配的两个玩家
func MatchPlayerPair(players []Player, targetPower int) []Player {
    powerMap := make(map[int]int)

    for i, player := range players {
        complement := targetPower - player.Power
        if j, exists := powerMap[complement]; exists {
            return []Player{players[j], player}
        }
        powerMap[player.Power] = i
    }
    return nil
}
```

**应用场景**：
- 平衡战力匹配
- 公平对战系统
- 团队组建优化

### 3. 数据分析 - 股票配对
```go
// 找到两支股票可以组成对冲投资组合
func FindStockHedgePair(stocks []Stock, targetReturn float64) []Stock {
    returnMap := make(map[float64]int)

    for i, stock := range stocks {
        complement := targetReturn - stock.ExpectedReturn
        if j, exists := returnMap[complement]; exists {
            return []Stock{stocks[j], stock}
        }
        returnMap[stock.ExpectedReturn] = i
    }
    return nil
}
```

**应用场景**：
- 风险对冲
- 投资组合优化
- 收益平衡配置

### 4. 缓存系统 - 内存管理
```go
// 内存块合并优化
func FindMemoryBlocks(blocks []int, targetSize int) []int {
    sizeMap := make(map[int]int)

    for i, size := range blocks {
        complement := targetSize - size
        if j, exists := sizeMap[complement]; exists {
            return []int{j, i}
        }
        sizeMap[size] = i
    }
    return nil
}
```

**应用场景**：
- 内存碎片整理
- 动态内存分配
- 资源池管理

### 5. 交通调度 - 路线规划
```go
// 找到两个配送点总距离最优
func FindDeliveryPair(points []Location, targetDistance float64) []Location {
    distMap := make(map[float64]int)

    for i, point := range points {
        complement := targetDistance - point.Distance
        if j, exists := distMap[complement]; exists {
            return []Location{points[j], point}
        }
        distMap[point.Distance] = i
    }
    return nil
}
```

**应用场景**：
- 配送路线优化
- 车辆调度系统
- 物流成本控制

## 📈 算法对比总结

| 方面 | 暴力解法 | HashMap解法 |
|------|----------|-------------|
| **时间复杂度** | O(n²) | O(n) |
| **空间复杂度** | O(1) | O(n) |
| **查找速度** | 线性查找 | 哈希查找 |
| **内存占用** | 低 | 较高 |
| **数据规模** | 适合小数据 | 适合大数据 |
| **实际性能** | 慢 | 快 |

### 性能对比（数据量10000）：
- **暴力解法**：约5000万次比较
- **HashMap解法**：约1万次操作 + 哈希计算

## 💡 扩展思考

### 变体1：三数之和
```go
func SumThree(nums []int) [][]int {
    // 先排序 + 双指针
    // 时间复杂度：O(n²)
}
```

### 变体2：重复数字处理
```go
func SumWithDuplicates(nums []int, target int) [][]int {
    // 需要考虑重复数字的所有组合
    // 返回所有可能的索引对
}
```

### 变体3：最接近目标值
```go
func SumClosest(nums []int, target int) []int {
    // 找到和最接近target的两个数
    // 不一定等于target
}
```

## 🎯 核心思想总结

**以空间换时间**是计算机科学中非常重要的优化策略：

1. **空间成本**：使用额外的HashMap存储中间结果
2. **时间收益**：将查找复杂度从O(n)降到O(1)
3. **适用场景**：数据量大、查找频繁、内存充足

这个思想不仅适用于两数之和，还可以推广到：
- **缓存系统**：用内存缓存加速数据访问
- **索引数据库**：用索引加速查询
- **预处理**：提前计算并存储结果

理解了这个核心思想，你就能解决更多类似的组合查找和优化问题！