# 滑动窗口算法详解

## 🎯 核心思想

滑动窗口用两个指针(left, right)维护一个动态窗口，通过向右扩张和向左收缩来寻找满足条件的连续区间。

```
字符串：a b c a b c b b
窗口：  ^^^^^       ← 窗口向右滑动
          ^^^^^     ← 继续滑动
            ^^^^^   ← 继续滑动
```

### 🔑 三大核心机制

#### 1. 记忆结构(Map/数组)
- **作用**：记录窗口内元素的"状态信息"
- **类型**：
  - `map[byte]int`：记录字符最后出现位置
  - `int[]`：计数窗口内各类元素数量
  - `int`：维护窗口总和等聚合信息
- **原理**：避免每次都重新扫描窗口

#### 2. 自动移动的right指针
- **固定节奏**：right永远**向右移动**，从不回退
- **职责**：
  - 不断探索新的可能性
  - 将新元素加入窗口
  - 更新记忆结构
- **特性**：每个元素**只进不出**

#### 3. 条件驱动的left指针
- **被动移动**：left**只在条件不满足时**才向右移动
- **职责**：
  - 舍弃不再符合条件的元素
  - 确保窗口始终满足约束条件
  - 维护窗口的有效性
- **特性**：确保每个元素**最多被剔除一次**

### 🎯 协同工作原理

```
right指针：不断向右探索，把新元素"请进"窗口
记忆结构：记录窗口状态，快速判断是否"超标"
left指针：发现窗口"超标"，把老元素"请出去"

就像：right→请客进门，map→数人头，left→请人离席
```

## 🚀 核心优势

### 1. 时间复杂度优势
- **O(n)线性时间**：每个元素最多访问2次（进入和离开窗口）
- **避免重复计算**：不需要暴力枚举所有子串
- **空间效率高**：通常只需要O(1)或O(k)额外空间

### 2. 算法思想简洁
- **双指针维护**：left和right指针定义窗口边界
- **单调性操作**：right只向右移动，left也只向右移动
- **实时调整**：根据条件动态收缩或扩张窗口

## 🎯 解决的问题类型

**核心特征：连续性约束问题**

### 1. 最值优化问题
- 无重复字符的最长子串
- 满足条件的最长子数组
- 最大/最小和的连续子数组

### 2. 统计计数问题
- 固定大小窗口内的元素统计
- 满足条件的子数组个数
- 窗口内不同元素的数量

### 3. 覆盖包含问题
- 包含所有目标字符的最短子串
- 满足多种条件的最小窗口

**关键识别点**：
- 问题涉及**连续的**子数组/子串
- 可以用**双指针**维护一个窗口
- 条件满足时可以**实时计算**结果

## 🔧 通用模板

### 模板1：可变窗口大小
```go
func slidingWindow(s string) int {
    left := 0
    result := 0
    window := make(map[byte]int)

    for right := 0; right < len(s); right++ {
        // 1. 扩大窗口：添加当前元素
        window[s[right]]++

        // 2. 收缩窗口：直到满足条件
        for !条件满足(window) {
            window[s[left]]--
            left++
        }

        // 3. 更新结果
        result = max(result, right-left+1)
    }

    return result
}
```

### 模板2：固定窗口大小
```go
func slidingWindowFixedSize(arr []int, k int) int {
    result := 0
    windowSum := 0

    // 初始化第一个窗口
    for i := 0; i < k; i++ {
        windowSum += arr[i]
    }
    result = windowSum

    // 滑动窗口
    for i := k; i < len(arr); i++ {
        // 移除最左边的元素，添加新元素
        windowSum += arr[i] - arr[i-k]
        result = max(result, windowSum)
    }

    return result
}
```

## 🆚 滑动窗口 vs 动态规划

| 特征维度 | 滑动窗口 | 动态规划 |
|---------|----------|----------|
| **问题类型** | **连续性**约束问题 | **不连续**的子序列/子问题 |
| **状态管理** | 当前窗口的**实时状态** | **历史状态**的记忆化存储 |
| **转移方式** | **指针移动**：left/right边界调整 | **状态转移方程**：dp[i] = f(之前状态) |
| **思维模式** | **贪心+双指针**：实时优化 | **递归+记忆化**：全局最优 |
| **存储需求** | O(1)或O(k)的窗口状态 | O(n)或O(n²)的状态表 |

### 核心区别总结
- **滑动窗口**：解决"找到一段连续的、满足条件的区间"
- **动态规划**：解决"从多个选择中找出最优的组合方案"

### 选择依据
- 需要连续性 → 滑动窗口
- 需要跳跃性选择 → 动态规划

## 📝 实例对比

### 滑动窗口问题：无重复字符的最长子串
```go
func LengthOfLongestSubstring(s string) int {
    charIndex := make(map[byte]int)
    left, maxLength := 0, 0

    for right := 0; right < len(s); right++ {
        currentChar := s[right]

        // 遇到重复字符，收缩窗口
        if lastPos, exists := charIndex[currentChar]; exists && lastPos >= left {
            left = lastPos + 1
        }

        charIndex[currentChar] = right
        maxLength = max(maxLength, right-left+1)
    }

    return maxLength
}
```

### 动态规划问题：最长递增子序列
```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))

    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j] + 1)  // 状态转移
            }
        }
    }

    return max(dp...)
}
```

## 💡 记忆技巧

### 滑动窗口的核心思想
```
"先扩大，再缩小，记最优"

扩大：right++ 不断探索新可能
缩小：left++  舍弃不符合的部分
记最优：更新最佳答案
```

### 与动态规划的区别
```
滑动窗口：连续问题 → 双指针移动
动态规划：不连续问题 → 状态转移方程

就像：
滑动窗口 = 手电筒照路 (连续的光束)
动态规划 = 走迷宫记路 (记住每一步的选择)
```

**掌握滑动窗口，你就掌握了一大类字符串和数组问题的解决方案！**🎉