# 二叉树最大深度详解 (小白版)

## 🌳 二叉树是什么？

### 生活中的比喻
想象一个家族的族谱：
```
        爷爷
       /    \
    爸爸     叔叔
   /   \     /
儿子   女儿  堂弟
```

每个人最多有2个孩子，这就是**二叉树**！

### 二叉树的基本概念
1. **节点（Node）**：像族谱里的每个人
2. **根节点（Root）**：最顶端的祖先（爷爷）
3. **左子树**：左边的后代分支
4. **右子树**：右边的后代分支
5. **叶子节点**：没有孩子的节点（儿子、女儿、堂弟）

### 代码中的二叉树
```go
type TreeNode struct {
    Val   int        // 节点的值（人的名字）
    Left  *TreeNode // 左孩子指针
    Right *TreeNode // 右孩子指针
}
```

## 📏 什么是二叉树的深度？

### 深度的定义
**深度 = 从根节点到最远叶子节点的层数**

还是用族谱例子：
```
  第1层：   爷爷    ← 根节点，深度从这里开始计算
         /      \
第2层：  爸爸      叔叔
       /    \      /
第3层：、儿子  女儿  堂弟    ← 最深的节点在第3层
```

所以这棵树的深度是 **3**。

### 更多例子
**例子1：只有根节点**
```
    10
```
深度 = 1

**例子2：左斜树**
```
    10
   /
  20
 /
30
```
深度 = 3

**例子3：完全二叉树**
```
    10
   /  \
  20   30
 /  \
40  50
```
深度 = 3

## 🔍 MaxDepth算法详解

### 算法核心思想：分治策略

**把大问题分解成小问题，分别解决再合并答案！**

## 🔢 递归算法详细解析

### 第1步：终止条件
```go
if root == nil {
    return 0
}
```
**含义**：如果是空树（没有节点），深度为0
**类比**：问"一个不存在的家族有几代人？" → 0代人

### 第2步：递归调用
```go
leftDepth := MaxDepth(root.Left)   // 计算左子树的深度
rightDepth := MaxDepth(root.Right) // 计算右子树的深度
```
**含义**：
- 问我左子树的深度
- 问我右子树的深度
- **递归**：函数会一直调用自己，直到遇到空节点

### 第3步：合并结果
```go
if leftDepth > rightDepth {
    return leftDepth + 1
} else {
    return rightDepth + 1
}
```
**含义**：
- 取左右子树深度的**最大值**
- **加1**：算上当前节点这一层

## 📊 具体例子分析

假设有这棵树：
```
    10
   /  \
  20   30
 /    \
40    50
```

### 计算过程：

**第1层：节点10**
```
MaxDepth(10) 调用：
├── MaxDepth(20)  ← 左子树
└── MaxDepth(30)  ← 右子树
```

**第2层：节点20和30**
```
MaxDepth(20) 调用：
├── MaxDepth(40)  ← 左子树
└── MaxDepth(nil) ← 右子树（空）

MaxDepth(30) 调用：
├── MaxDepth(nil) ← 左子树（空）
└── MaxDepth(50)  ← 右子树
```

**第3层：叶子节点**
```
MaxDepth(40) 调用：
├── MaxDepth(nil) ← 左子树（空）
└── MaxDepth(nil) ← 右子树（空）

MaxDepth(50) 调用：
├── MaxDepth(nil) ← 左子树（空）
└── MaxDepth(nil) ← 右子树（空）
```

### 回溯计算：

**第3层结果**：
- `MaxDepth(40) = max(0, 0) + 1 = 1`
- `MaxDepth(50) = max(0, 0) + 1 = 1`

**第2层结果**：
- `MaxDepth(20) = max(1, 0) + 1 = 2`
- `MaxDepth(30) = max(0, 1) + 1 = 2`

**第1层结果**：
- `MaxDepth(10) = max(2, 2) + 1 = 3`

**最终答案：3**

## 🧠 算法的威力

### 为什么递归这么厉害？
1. **自动分解问题**：你只需要告诉计算机如何处理最简单的情况
2. **记住中间结果**：计算机会帮你记住每一步的结果
3. **自动合并答案**：按照你定义的规则自动组合

### 时间复杂度：O(n)
- 每个节点只访问一次
- n是节点总数

### 空间复杂度：O(h)
- h是树的高度
- 递归调用栈最多存储h个函数调用

## 💡 迭代解法（BFS层次遍历）

除了递归，还可以用**广度优先搜索（BFS）**来解决问题：

### BFS算法思路
1. **队列**：用队列来存储每一层的节点
2. **层次遍历**：一次处理一层的所有节点
3. **计数**：每处理完一层，深度加1

### BFS代码解析
```go
func MaxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    queue := []*TreeNode{root}  // 队列，初始只包含根节点
    depth := 0

    for len(queue) > 0 {
        // 处理当前层的所有节点
        levelSize := len(queue)  // 当前层的节点数量
        depth++

        for i := 0; i < levelSize; i++ {
            node := queue[0]      // 取出队首节点
            queue = queue[1:]     // 队首出队

            // 将下一层节点加入队列
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }

    return depth
}
```

### BFS执行过程（同样例子）
```
初始：queue = [10], depth = 0

第1层处理：
- 处理10，加入20, 30
- queue = [20, 30], depth = 1

第2层处理：
- 处理20，加入40
- 处理30，加入50
- queue = [40, 50], depth = 2

第3层处理：
- 处理40，无子节点
- 处理50，无子节点
- queue = [], depth = 3

结束：返回depth = 3
```

## 🎯 两种解法对比

| 特点 | 递归解法 | 迭代解法（BFS） |
|------|----------|-----------------|
| **代码简洁性** | ✅ 很简洁 | ❌ 较复杂 |
| **空间复杂度** | O(h) | O(n) |
| **时间复杂度** | O(n) | O(n) |
| **理解难度** | ❌ 需要递归思维 | ✅ 更直观 |
| **适用场景** | 简单问题 | 需要控制空间时 |

## 🚀 扩展应用

这个算法模式可以用于解决很多类似问题：

### 1. 判断是否为平衡二叉树
```go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }

    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)

    // 左右子树深度差不能超过1，且子树也必须平衡
    return abs(leftDepth - rightDepth) <= 1 &&
           isBalanced(root.Left) &&
           isBalanced(root.Right)
}
```

### 2. 计算树的直径
```go
// 直径 = 任意两个节点间的最长路径
func diameterOfBinaryTree(root *TreeNode) int {
    var result int

    maxDepth := func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        left := maxDepth(node.Left)
        right := maxDepth(node.Right)
        // 更新直径（左深度 + 右深度）
        result = max(result, left + right)
        return max(left, right) + 1
    }

    maxDepth(root)
    return result
}
```

### 3. 路径总和问题
```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }

    // 叶子节点，检查是否等于目标和
    if root.Left == nil && root.Right == nil {
        return root.Val == targetSum
    }

    // 递归检查左右子树
    return hasPathSum(root.Left, targetSum - root.Val) ||
           hasPathSum(root.Right, targetSum - root.Val)
}
```

## 📝 总结

**二叉树最大深度算法的核心思想**：
1. **递归终止**：空树深度为0
2. **分解问题**：分别计算左右子树的深度
3. **合并答案**：取最大值加1

**这个算法的美妙之处**：
- 你只需要告诉计算机"怎么处理当前节点"
- 计算机会自动处理所有子节点
- 最终自动返回正确答案

**递归的思维模式**：
- 把问题分解成更小的相同问题
- 找到最简单的情况（终止条件）
- 定义如何将子问题的答案合并

就像告诉孩子："想知道家族有几代人？先问你爸那一代有几人，再问你叔叔那一代有几人，取最长的再加1！"

这就是递归的魅力！掌握了这个思维模式，你就能解决很多树形结构的问题！