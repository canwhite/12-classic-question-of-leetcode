# é€’å½’åº”ç”¨åœºæ™¯è¯¦è§£ (å…¨é¢†åŸŸæŒ‡å—)

## ğŸŒŸ é€’å½’çš„é€šç”¨æ€§

**é€’å½’ä¸ä»…ä»…æ˜¯å¤„ç†æ ‘çš„å·¥å…·ï¼Œå®ƒæ˜¯é€šç”¨çš„ç¼–ç¨‹æ€æƒ³ï¼**

é€’å½’è§£å†³çš„æ˜¯**å¯ä»¥åˆ†è§£çš„å­é—®é¢˜**ï¼š
1. **ç›¸åŒç»“æ„**ï¼šå­é—®é¢˜ä¸åŸé—®é¢˜ç»“æ„ç›¸ä¼¼
2. **è§„æ¨¡é€’å‡**ï¼šå­é—®é¢˜è§„æ¨¡æ›´å°
3. **è¾¹ç•Œæ¡ä»¶**ï¼šæœ‰æ˜ç¡®çš„ç»ˆæ­¢æ¡ä»¶
4. **åˆ†æ²»åˆå¹¶**ï¼šå­é—®é¢˜ç­”æ¡ˆå¯ä»¥åˆå¹¶

---

## ğŸ§® 1. æ•°å­¦é—®é¢˜

### é˜¶ä¹˜
```go
func factorial(n int) int {
    if n <= 1 {
        return 1  // ç»ˆæ­¢æ¡ä»¶
    }
    return n * factorial(n-1)  // n! = n * (n-1)!
}
```

**é€’å½’æ€ç»´**ï¼šnçš„é˜¶ä¹˜ = n Ã— (n-1çš„é˜¶ä¹˜)

### æ–æ³¢é‚£å¥‘æ•°åˆ—
```go
func fibonacci(n int) int {
    if n <= 1 {
        return n  // F(0)=0, F(1)=1
    }
    return fibonacci(n-1) + fibonacci(n-2)  // F(n) = F(n-1) + F(n-2)
}
```

**é€’å½’æ€ç»´**ï¼šç¬¬nä¸ªæ•° = å‰ä¸¤ä¸ªæ•°ä¹‹å’Œ

### æœ€å¤§å…¬çº¦æ•°ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
```go
func gcd(a, b int) int {
    if b == 0 {
        return a  // ç»ˆæ­¢æ¡ä»¶
    }
    return gcd(b, a%b)  // gcd(a,b) = gcd(b,a%b)
}
```

**é€’å½’æ€ç»´**ï¼šä¸¤æ•°æœ€å¤§å…¬çº¦æ•° = è¾ƒå°æ•°ä¸ä½™æ•°çš„æœ€å¤§å…¬çº¦æ•°

### å¹‚è¿ç®—
```go
func power(base, exponent int) int {
    if exponent == 0 {
        return 1  // ä»»ä½•æ•°çš„0æ¬¡æ–¹ç­‰äº1
    }
    return base * power(base, exponent-1)  // x^n = x * x^(n-1)
}
```

---

## ğŸ“Š 2. æ•°ç»„å’Œå­—ç¬¦ä¸²

### åè½¬å­—ç¬¦ä¸²
```go
func reverseString(s string) string {
    if len(s) <= 1 {
        return s  // ç»ˆæ­¢æ¡ä»¶
    }
    return reverseString(s[1:]) + s[0:1]  // åè½¬å‰©ä½™ + ç¬¬ä¸€ä¸ªå­—ç¬¦
}
```

**æ‰§è¡Œè¿‡ç¨‹**ï¼š
```
reverseString("abc")
= reverseString("bc") + "a"
= (reverseString("c") + "b") + "a"
= ("c" + "b") + "a"
= "cba"
```

### æ•°ç»„æ±‚å’Œ
```go
func sumArray(arr []int) int {
    if len(arr) == 0 {
        return 0  // ç©ºæ•°ç»„å’Œä¸º0
    }
    return arr[0] + sumArray(arr[1:])  // ç¬¬ä¸€ä¸ªæ•° + å‰©ä½™æ•°ç»„çš„å’Œ
}
```

### æŸ¥æ‰¾æœ€å¤§å€¼
```go
func findMax(arr []int) int {
    if len(arr) == 1 {
        return arr[0]  // åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œå®ƒå°±æ˜¯æœ€å¤§å€¼
    }
    maxInRest := findMax(arr[1:])  // å‰©ä½™æ•°ç»„çš„æœ€å¤§å€¼
    if arr[0] > maxInRest {
        return arr[0]  // ç¬¬ä¸€ä¸ªå…ƒç´ æ›´å¤§
    }
    return maxInRest  // å‰©ä½™æ•°ç»„çš„æœ€å¤§å€¼æ›´å¤§
}
```

### äºŒåˆ†æŸ¥æ‰¾
```go
func binarySearch(arr []int, target, left, right int) int {
    if left > right {
        return -1  // æ²¡æ‰¾åˆ°
    }

    mid := (left + right) / 2

    if arr[mid] == target {
        return mid  // æ‰¾åˆ°äº†
    } else if arr[mid] > target {
        return binarySearch(arr, target, left, mid-1)  // æŸ¥æ‰¾å·¦åŠ
    } else {
        return binarySearch(arr, target, mid+1, right)  // æŸ¥æ‰¾å³åŠ
    }
}
```

---

## ğŸ”„ 3. æ’åˆ—ç»„åˆ

### ç”Ÿæˆæ‰€æœ‰æ’åˆ—
```go
func permutations(nums []int) [][]int {
    var result [][]int

    var generate func([]int, []int)
    generate = func(remaining []int, current []int) {
        if len(remaining) == 0 {
            result = append(result, append([]int{}, current...))
            return
        }

        for i, num := range remaining {
            // é€‰æ‹©å½“å‰æ•°å­—
            newCurrent := append(current, num)
            newRemaining := make([]int, 0, len(remaining)-1)
            newRemaining = append(newRemaining, remaining[:i]...)
            newRemaining = append(newRemaining, remaining[i+1:]...)

            generate(newRemaining, newCurrent)
        }
    }

    generate(nums, []int{})
    return result
}
```

**æ‰§è¡Œè¿‡ç¨‹**ï¼š
```
permutations([1,2,3])
â†’ é€‰æ‹©1ï¼Œæ’åˆ—[2,3]
â†’ é€‰æ‹©2ï¼Œæ’åˆ—[3]
â†’ [1,2,3]
â†’ [1,3,2]
â†’ é€‰æ‹©2ï¼Œæ’åˆ—[1,3]
â†’ [2,1,3]
â†’ [2,3,1]
â†’ é€‰æ‹©3ï¼Œæ’åˆ—[1,2]
â†’ [3,1,2]
â†’ [3,2,1]
```

### å­é›†ç”Ÿæˆ
```go
func subsets(nums []int) [][]int {
    var result [][]int

    var generate func(int, []int)
    generate = func(index int, current []int) {
        if index == len(nums) {
            result = append(result, append([]int{}, current...))
            return
        }

        // ä¸åŒ…å«å½“å‰å…ƒç´ 
        generate(index+1, current)

        // åŒ…å«å½“å‰å…ƒç´ 
        current = append(current, nums[index])
        generate(index+1, current)
    }

    generate(0, []int{})
    return result
}
```

**æ€ç»´**ï¼šæ¯ä¸ªå…ƒç´ éƒ½æœ‰"é€‰"å’Œ"ä¸é€‰"ä¸¤ç§é€‰æ‹©

---

## âš¡ 4. åˆ†æ²»ç®—æ³•

### å¿«é€Ÿæ’åº
```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr  // ç»ˆæ­¢æ¡ä»¶
    }

    pivot := arr[0]  // é€‰æ‹©åŸºå‡†
    var left, right []int

    // åˆ†åŒº
    for i := 1; i < len(arr); i++ {
        if arr[i] <= pivot {
            left = append(left, arr[i])
        } else {
            right = append(right, arr[i])
        }
    }

    // é€’å½’æ’åºå¹¶åˆå¹¶
    sortedLeft := quickSort(left)
    sortedRight := quickSort(right)

    return append(append(sortedLeft, pivot), sortedRight...)
}
```

**é€’å½’æ€ç»´**ï¼š
1. **åˆ†è§£**ï¼šé€‰æ‹©åŸºå‡†ï¼Œåˆ†æˆå°äºå’Œå¤§äºåŸºå‡†çš„ä¸¤éƒ¨åˆ†
2. **è§£å†³**ï¼šé€’å½’æ’åºä¸¤éƒ¨åˆ†
3. **åˆå¹¶**ï¼šç»„åˆç»“æœ

### å½’å¹¶æ’åº
```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr  // ç»ˆæ­¢æ¡ä»¶
    }

    mid := len(arr) / 2
    left := mergeSort(arr[:mid])    // é€’å½’æ’åºå·¦åŠ
    right := mergeSort(arr[mid:])   // é€’å½’æ’åºå³åŠ

    return merge(left, right)       // åˆå¹¶æœ‰åºæ•°ç»„
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0

    // åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }

    // æ·»åŠ å‰©ä½™å…ƒç´ 
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)

    return result
}
```

---

## ğŸ” 5. æœç´¢ç®—æ³•

### æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆå›¾ï¼‰
```go
func dfs(graph map[int][]int, node int, visited map[int]bool) []int {
    var result []int
    visited[node] = true
    result = append(result, node)

    // é€’å½’è®¿é—®æ‰€æœ‰é‚»å±…
    for _, neighbor := range graph[node] {
        if !visited[neighbor] {
            result = append(result, dfs(graph, neighbor, visited)...)
        }
    }

    return result
}
```

### æ±‰è¯ºå¡”é—®é¢˜
```go
func hanoi(n int, source, target, auxiliary string) []string {
    var moves []string

    var solve func(int, string, string, string)
    solve = func(n, source, target, auxiliary string) {
        if n == 1 {
            moves = append(moves, source+" â†’ "+target)
            return
        }

        // å°†n-1ä¸ªç›˜å­ä»æºç§»åˆ°è¾…åŠ©æŸ±
        solve(n-1, source, auxiliary, target)
        // å°†æœ€å¤§ç›˜å­ç§»åˆ°ç›®æ ‡æŸ±
        moves = append(moves, source+" â†’ "+target)
        // å°†n-1ä¸ªç›˜å­ä»è¾…åŠ©æŸ±ç§»åˆ°ç›®æ ‡æŸ±
        solve(n-1, auxiliary, target, source)
    }

    solve(n, source, target, auxiliary)
    return moves
}
```

**é€’å½’æ€ç»´**ï¼šç§»åŠ¨nä¸ªç›˜å­ = ç§»åŠ¨n-1ä¸ªç›˜å­ + ç§»åŠ¨æœ€å¤§ç›˜å­ + ç§»åŠ¨n-1ä¸ªç›˜å­

---

## ğŸ’ 6. åŠ¨æ€è§„åˆ’

### èƒŒåŒ…é—®é¢˜
```go
func knapsack(weights, values []int, capacity int) int {
    memo := make(map[string]int)  // è®°å¿†åŒ–

    var solve func(int, int) int
    solve = func(index, remainingCapacity int) int {
        // ç»ˆæ­¢æ¡ä»¶
        if index == len(weights) || remainingCapacity == 0 {
            return 0
        }

        // æ£€æŸ¥è®°å¿†åŒ–
        key := fmt.Sprintf("%d,%d", index, remainingCapacity)
        if val, exists := memo[key]; exists {
            return val
        }

        // ä¸é€‰å½“å‰ç‰©å“
        notTake := solve(index+1, remainingCapacity)

        // é€‰å½“å‰ç‰©å“ï¼ˆå¦‚æœèƒ½è£…ä¸‹ï¼‰
        take := 0
        if weights[index] <= remainingCapacity {
            take = values[index] + solve(index+1, remainingCapacity-weights[index])
        }

        memo[key] = max(notTake, take)
        return memo[key]
    }

    return solve(0, capacity)
}
```

### æœ€é•¿å…¬å…±å­åºåˆ—
```go
func longestCommonSubsequence(s1, s2 string) int {
    memo := make(map[string]int)

    var solve func(int, int) int
    solve = func(i, j int) int {
        // ç»ˆæ­¢æ¡ä»¶
        if i >= len(s1) || j >= len(s2) {
            return 0
        }

        key := fmt.Sprintf("%d,%d", i, j)
        if val, exists := memo[key]; exists {
            return val
        }

        if s1[i] == s2[j] {
            // å­—ç¬¦åŒ¹é…
            memo[key] = 1 + solve(i+1, j+1)
        } else {
            // å­—ç¬¦ä¸åŒ¹é…ï¼Œè·³è¿‡å…¶ä¸­ä¸€ä¸ª
            memo[key] = max(solve(i+1, j), solve(i, j+1))
        }

        return memo[key]
    }

    return solve(0, 0)
}
```

---

## ğŸ® 7. å›æº¯ç®—æ³•

### Nçš‡åé—®é¢˜
```go
func solveNQueens(n int) [][]string {
    var result [][]string
    board := make([][]string, n)
    for i := range board {
        board[i] = make([]string, n)
        for j := range board[i] {
            board[i][j] = "."
        }
    }

    var backtrack func(int)
    backtrack = func(row int) {
        if row == n {
            // æ‰¾åˆ°ä¸€ä¸ªè§£å†³æ–¹æ¡ˆ
            solution := make([]string, n)
            for i := range board {
                solution[i] = strings.Join(board[i], "")
            }
            result = append(result, solution)
            return
        }

        for col := 0; col < n; col++ {
            if isValid(board, row, col, n) {
                board[row][col] = "Q"  // æ”¾ç½®çš‡å
                backtrack(row + 1)      // ç»§ç»­ä¸‹ä¸€è¡Œ
                board[row][col] = "."  // å›æº¯
            }
        }
    }

    backtrack(0)
    return result
}

func isValid(board [][]string, row, col, n int) bool {
    // æ£€æŸ¥åˆ—
    for i := 0; i < row; i++ {
        if board[i][col] == "Q" {
            return false
        }
    }

    // æ£€æŸ¥å·¦å¯¹è§’çº¿
    for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
        if board[i][j] == "Q" {
            return false
        }
    }

    // æ£€æŸ¥å³å¯¹è§’çº¿
    for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 {
        if board[i][j] == "Q" {
            return false
        }
    }

    return true
}
```

### æ•°ç‹¬æ±‚è§£
```go
func solveSudoku(board [][]byte) bool {
    for i := 0; i < 9; i++ {
        for j := 0; j < 9; j++ {
            if board[i][j] == '.' {
                for digit := byte('1'); digit <= byte('9'); digit++ {
                    if isValidSudoku(board, i, j, digit) {
                        board[i][j] = digit  // æ”¾ç½®æ•°å­—

                        if solveSudoku(board) {  // é€’å½’æ±‚è§£
                            return true
                        }

                        board[i][j] = '.'  // å›æº¯
                    }
                }
                return false  // æ²¡æœ‰åˆé€‚çš„æ•°å­—
            }
        }
    }
    return true  // æ±‚è§£æˆåŠŸ
}
```

---

## ğŸ”— 8. é“¾è¡¨æ“ä½œ

### åè½¬é“¾è¡¨
```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head  // ç©ºé“¾è¡¨æˆ–åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
    }

    newHead := reverseList(head.Next)  // é€’å½’åè½¬å‰©ä½™éƒ¨åˆ†
    head.Next.Next = head             // è¿æ¥å½“å‰èŠ‚ç‚¹
    head.Next = nil                  // æ–­å¼€åŸæ¥è¿æ¥
    return newHead
}
```

**æ‰§è¡Œè¿‡ç¨‹**ï¼š
```
1â†’2â†’3â†’nil

reverseList(1):
  reverseList(2):
    reverseList(3):
      return 3
    2â†’3, 2â†’nil
    return 2
  1â†’2â†’3, 1â†’nil
  return 1

ç»“æœï¼š1â†’2â†’3â†’nil å˜æˆ 3â†’2â†’1â†’nil
```

### åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
```go
func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

---

## ğŸŒ² 9. æ ‘çš„é«˜çº§æ“ä½œ

### æ”¶é›†æ‰€æœ‰è·¯å¾„
```go
func allPaths(root *TreeNode) [][]int {
    var paths [][]int

    var dfs func(*TreeNode, []int)
    dfs = func(node *TreeNode, currentPath []int) {
        if node == nil {
            return
        }

        currentPath = append(currentPath, node.Val)

        // å¶å­èŠ‚ç‚¹ï¼Œè®°å½•è·¯å¾„
        if node.Left == nil && node.Right == nil {
            path := make([]int, len(currentPath))
            copy(path, currentPath)
            paths = append(paths, path)
        } else {
            // ç»§ç»­é€’å½’
            dfs(node.Left, currentPath)
            dfs(node.Right, currentPath)
        }
    }

    dfs(root, []int{})
    return paths
}
```

### åºåˆ—åŒ–å’Œååºåˆ—åŒ–
```go
func serialize(root *TreeNode) string {
    if root == nil {
        return "null,"
    }

    return fmt.Sprintf("%d,", root.Val) +
           serialize(root.Left) +
           serialize(root.Right)
}

func deserialize(data string) *TreeNode {
    values := strings.Split(data, ",")
    index := 0

    var build func() *TreeNode
    build = func() *TreeNode {
        if values[index] == "null" {
            index++
            return nil
        }

        val, _ := strconv.Atoi(values[index])
        index++

        return &TreeNode{
            Val:   val,
            Left:  build(),
            Right: build(),
        }
    }

    return build()
}
```

---

## ğŸ“ˆ é€’å½’çš„ä¼˜åŒ–æŠ€å·§

### 1. è®°å¿†åŒ–ï¼ˆMemoizationï¼‰
```go
func fib(n int) int {
    memo := make(map[int]int)

    var helper func(int) int
    helper = func(x int) int {
        if x <= 1 {
            return x
        }
        if val, exists := memo[x]; exists {
            return val
        }

        memo[x] = helper(x-1) + helper(x-2)
        return memo[x]
    }

    return helper(n)
}
```

### 2. å°¾é€’å½’ä¼˜åŒ–
```go
// æ™®é€šé€’å½’ï¼ˆå¯èƒ½æ ˆæº¢å‡ºï¼‰
func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)
}

// å°¾é€’å½’ï¼ˆç¼–è¯‘å™¨å¯ä¼˜åŒ–ï¼‰
func factorialTail(n, acc int) int {
    if n <= 1 {
        return acc
    }
    return factorialTail(n-1, acc*n)
}
```

### 3. é€’å½’è½¬è¿­ä»£
```go
// é€’å½’ç‰ˆæœ¬
func sumArrayRecursive(arr []int, index int) int {
    if index == len(arr) {
        return 0
    }
    return arr[index] + sumArrayRecursive(arr, index+1)
}

// è¿­ä»£ç‰ˆæœ¬
func sumArrayIterative(arr []int) int {
    sum := 0
    for _, num := range arr {
        sum += num
    }
    return sum
}
```

---

## ğŸ¯ ä»€ä¹ˆæ—¶å€™ä½¿ç”¨é€’å½’ï¼Ÿ

### âœ… é€‚åˆé€’å½’çš„åœºæ™¯

1. **æ ‘/å›¾ç»“æ„**
   - éå†ã€æœç´¢ã€è·¯å¾„æŸ¥æ‰¾

2. **åˆ†æ²»ç®—æ³•**
   - å¿«é€Ÿæ’åºã€å½’å¹¶æ’åºã€äºŒåˆ†æŸ¥æ‰¾

3. **å›æº¯æœç´¢**
   - Nçš‡åã€æ•°ç‹¬ã€æ’åˆ—ç»„åˆ

4. **æ•°å­¦é€’æ¨å…³ç³»**
   - æ–æ³¢é‚£å¥‘ã€é˜¶ä¹˜ã€å¹‚è¿ç®—

5. **é“¾è¡¨æ“ä½œ**
   - åè½¬ã€åˆå¹¶ã€ç¯æ£€æµ‹

6. **åŠ¨æ€è§„åˆ’**
   - èƒŒåŒ…é—®é¢˜ã€æœ€é•¿å­åºåˆ—

### âŒ ä¸é€‚åˆé€’å½’çš„åœºæ™¯

1. **ç®€å•å¾ªç¯**
   - ç´¯åŠ ã€æ•°ç»„éå†
   ```go
   // ä¸æ¨è
   func sumRecursive(arr []int, i int) int {
       if i == len(arr) { return 0 }
       return arr[i] + sumRecursive(arr, i+1)
   }

   // æ¨è
   func sumIterative(arr []int) int {
       sum := 0
       for _, num := range arr { sum += num }
       return sum
   }
   ```

2. **éœ€è¦ç²¾ç¡®æ§åˆ¶å†…å­˜çš„åœºæ™¯**
   - åµŒå…¥å¼ç³»ç»Ÿã€å†…å­˜å—é™ç¯å¢ƒ

3. **é€’å½’æ·±åº¦è¿‡å¤§çš„åœºæ™¯**
   - é“¾è¡¨è¿‡é•¿ã€æ ‘æ·±åº¦è¿‡å¤§ï¼ˆæ ˆæº¢å‡ºï¼‰

4. **æ€§èƒ½æ•æ„Ÿçš„åœºæ™¯**
   - é€’å½’è°ƒç”¨å¼€é”€ã€å†…å­˜åˆ†é…

## ğŸ’¡ é€’å½’æ€ç»´è®­ç»ƒ

### ç»ƒä¹ æ­¥éª¤

1. **è¯†åˆ«é€’å½’æ¨¡å¼**
   - é—®é¢˜æ˜¯å¦å¯ä»¥åˆ†è§£ä¸ºæ›´å°çš„ç›¸åŒé—®é¢˜ï¼Ÿ

2. **å®šä¹‰ç»ˆæ­¢æ¡ä»¶**
   - æœ€ç®€å•çš„æƒ…å†µæ˜¯ä»€ä¹ˆï¼Ÿ

3. **è®¾è®¡é€’å½’å…³ç³»**
   - å¤§é—®é¢˜å¦‚ä½•ä»å­é—®é¢˜æ„å»ºï¼Ÿ

4. **è€ƒè™‘ä¼˜åŒ–**
   - æ˜¯å¦éœ€è¦è®°å¿†åŒ–ï¼Ÿèƒ½å¦è½¬ä¸ºè¿­ä»£ï¼Ÿ

### è°ƒè¯•æŠ€å·§

1. **æ‰“å°è°ƒè¯•**
   ```go
   func debugRecursion(n int, indent int) int {
       fmt.Printf("%sè°ƒç”¨: %d\n", strings.Repeat("  ", indent), n)

       if n <= 1 {
           return n
       }

       result := debugRecursion(n-1, indent+1) + debugRecursion(n-2, indent+1)
       fmt.Printf("%sè¿”å›: %d\n", strings.Repeat("  ", indent), result)
       return result
   }
   ```

2. **æ ˆè¿½è¸ª**
   ```go
   func fibWithTrace(n int) int {
       defer func() {
           fmt.Printf("è¿”å› fib(%d)\n", n)
       }()
       fmt.Printf("è°ƒç”¨ fib(%d)\n", n)

       if n <= 1 {
           return n
       }

       return fibWithTrace(n-1) + fibWithTrace(n-2)
   }
   ```

## ğŸš€ æ€»ç»“

é€’å½’æ˜¯ä¸€ç§å¼ºå¤§çš„ç¼–ç¨‹æ€ç»´ï¼Œå®ƒèƒ½è®©ä½ ï¼š

1. **ç”¨ç®€æ´çš„ä»£ç è§£å†³å¤æ‚é—®é¢˜**
2. **è‡ªç„¶åœ°è¡¨è¾¾åˆ†æ²»æ€æƒ³**
3. **ä¼˜é›…åœ°å¤„ç†æ ‘å½¢å’Œé€’å½’ç»“æ„**
4. **ç®€åŒ–æœç´¢å’Œå›æº¯ç®—æ³•**

**æŒæ¡é€’å½’çš„å…³é”®ï¼š**
- ç†è§£"åˆ†è§£-è§£å†³-åˆå¹¶"çš„æ€ç»´æ¨¡å¼
- è¯†åˆ«é€‚åˆé€’å½’çš„é—®é¢˜ç‰¹å¾
- çŸ¥é“ä½•æ—¶ä½¿ç”¨è¿­ä»£æ›´åˆé€‚

é€’å½’ä¸ä»…æ˜¯ç¼–ç¨‹æŠ€å·§ï¼Œæ›´æ˜¯ä¸€ç§é‡è¦çš„æ€ç»´æ–¹å¼ï¼